--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -51,11 +51,58 @@
 #define SKB_FROM_XMIT_CLEAN		(1<<2)
 #define RETFREEQ_SKB            (1<<16)
 #define RETFREEQ_DATA           (1<<17)
+#ifdef CONFIG_BCM96362
+typedef void (*RecycleFuncP)(void * nbuff_p, unsigned context, unsigned flags);
+#define SKB_DATA_RECYCLE        (1<<0)
+#define SKB_RECYCLE				(1<<1)
+#define SKB_DATA_NO_RECYCLE		(~SKB_DATA_RECYCLE)	/* for masking out */
+#define SKB_NO_RECYCLE     		(~SKB_RECYCLE)		/* for masking out */
+
+/* queue = mark[4:0] */
+#define SKBMARK_Q_S             0
+#define SKBMARK_Q_M             (0x1F << SKBMARK_Q_S)
+#define SKBMARK_GET_Q(MARK)     ((MARK & SKBMARK_Q_M) >> SKBMARK_Q_S)
+#define SKBMARK_SET_Q(MARK, Q)  ((MARK & ~SKBMARK_Q_M) | (Q << SKBMARK_Q_S))
+/* traffic_class_id = mark[10:5] */
+#define SKBMARK_TC_ID_S         5
+#define SKBMARK_TC_ID_M         (0x3F << SKBMARK_TC_ID_S)
+#define SKBMARK_GET_TC_ID(MARK) ((MARK & SKBMARK_TC_ID_M) >> SKBMARK_TC_ID_S)
+#define SKBMARK_SET_TC_ID(MARK, TC) \
+    ((MARK & ~SKBMARK_TC_ID_M) | (TC << SKBMARK_TC_ID_S))
+/* flow_id = mark[18:11] */
+#define SKBMARK_FLOW_ID_S       11
+#define SKBMARK_FLOW_ID_M       (0xFF << SKBMARK_FLOW_ID_S)
+#define SKBMARK_GET_FLOW_ID(MARK) \
+    ((MARK & SKBMARK_FLOW_ID_M) >> SKBMARK_FLOW_ID_S)
+#define SKBMARK_SET_FLOW_ID(MARK, FLOW) \
+    ((MARK & ~SKBMARK_FLOW_ID_M) | (FLOW << SKBMARK_FLOW_ID_S))
+/* port = mark[26:19]; for enet driver of gpon port, this is gem_id */
+#define SKBMARK_PORT_S          19
+#define SKBMARK_PORT_M          (0xFF << SKBMARK_PORT_S)
+#define SKBMARK_GET_PORT(MARK) \
+    ((MARK & SKBMARK_PORT_M) >> SKBMARK_PORT_S)
+#define SKBMARK_SET_PORT(MARK, PORT) \
+    ((MARK & ~SKBMARK_PORT_M) | (PORT << SKBMARK_PORT_S))
+/* ipsec_mark = mark[28] */
+#define SKBMARK_IPSEC_MARK_S    28
+#define SKBMARK_IPSEC_MARK_M    (0x01 << SKBMARK_IPSEC_MARK_S)
+#define SKBMARK_GET_IPSEC_MARK(MARK) \
+    ((MARK & SKBMARK_IPSEC_MARK_M) >> SKBMARK_IPSEC_MARK_S)
+#define SKBMARK_SET_IPSEC_MARK(MARK, IPSEC_MARK) \
+    ((MARK & ~SKBMARK_IPSEC_MARK_M) | (IPSEC_MARK << SKBMARK_IPSEC_MARK_S))
+/* policy_routing = mark[31:29] */
+#define SKBMARK_POLICY_RTNG_S   29
+#define SKBMARK_POLICY_RTNG_M   (0x07 << SKBMARK_POLICY_RTNG_S)
+#define SKBMARK_GET_POLICY_RTNG(MARK)  \
+    ((MARK & SKBMARK_POLICY_RTNG_M) >> SKBMARK_POLICY_RTNG_S)
+#define SKBMARK_SET_POLICY_RTNG(MARK, POLICY) \
+    ((MARK & ~SKBMARK_POLICY_RTNG_M) | (POLICY << SKBMARK_POLICY_RTNG_S))
+#endif /* 6362 */
+
 #if defined(CONFIG_BLOG)
 struct blog_t;
 #endif
-#endif
-
+#endif	/* defined(CONFIG_MIPS_BRCM) */
 
 /* A. Checksumming of received packets by device.
  *
@@ -245,15 +292,30 @@ struct sk_buff {
 	struct sk_buff		*next;
 	struct sk_buff		*prev;
 
+	struct net_device	*dev;
+
 #if defined(CONFIG_MIPS_BRCM) // BRCM change Begin
-	struct sk_buff_head     *list;
+	/*
+	 * Several skb fields have been regrouped together for better data locality
+	 * cache performance, 16byte cache line proximity.
+	 */
+	struct sk_buff_head *list;  /* ____cacheline_aligned */
 #if defined(CONFIG_BLOG)
-    struct blog_t           *blog_p;
+	struct blog_t	*blog_p;
 #endif
+#ifdef CONFIG_BCM96362
+	/* Recycling of preallocated skb or data buffer */
+	RecycleFuncP	recycle_hook;
+	union {
+		__u32       recycle_context;	
+		struct sk_buff *next_free;
+	};
+    __u32			recycle_flags;  /* 3 bytes unused */
+
+#endif /* 6362 */
 #endif // BRCM change End
 	struct sock		*sk;
 	struct skb_timeval	tstamp;
-	struct net_device	*dev;
 	int			iif;
 	/* 4 byte hole on 64 bit*/
 
@@ -338,8 +400,10 @@ struct sk_buff {
 	__u32			mark;
 
 #if defined(CONFIG_MIPS_BRCM)
-   __u16			vtag;
-   __u16       vtag_save;
+	union {
+		__u32		vtag_word;
+   		struct 		{ __u16 vtag, vtag_save; };
+	};
 #endif
 
 #if defined(CONFIG_MIPS_BRCM)
@@ -451,6 +515,7 @@ extern unsigned int   skb_find_text(stru
 #define skb_shinfo(SKB)		((struct skb_shared_info *)((SKB)->end))
 
 #if defined(CONFIG_MIPS_BRCM)
+#ifdef CONFIG_BCM96358
 /**
  *	skb_headerinit	-	initialize a socket buffer header
  *	@size: size to allocate
@@ -489,7 +554,62 @@ static inline void skb_hdrinit(unsigned
 	skb_shinfo(skb)->ip6_frag_id = 0;	
 	skb_shinfo(skb)->frag_list = NULL;
 }
+#endif /* 6358 */
+
+#ifdef CONFIG_BCM96362
+/**
+ *	skb_headerinit	-	initialize a socket buffer header
+ *  @headroom: reserved headroom size
+ *	@size: size to allocate
+ *	@skb: skb allocated by caller
+ *	@data: data buffer allocated by caller
+ *	@recycle_hook: callback function to free data buffer and skb
+ *	@recycle_context: context value passed to recycle_hook, param1
+ *  @blog: to pass a blog for skb logging
+ *
+ *	Initializes the socket buffer and assigns the data buffer to it.
+ *
+ */
+static inline void skb_headerinit(unsigned headroom, unsigned size,
+                        struct sk_buff *skb, unsigned char *data,
+	                    RecycleFuncP recycle_hook, unsigned recycle_context,
+                        void * blog_p)
+{
+	memset(skb, 0, offsetof(struct sk_buff, truesize));
+
+	skb->truesize = size + sizeof(struct sk_buff);
+	atomic_set(&skb->users, 1);
+	skb->head = data - headroom;
+	skb->data = data;
+	skb->tail = data + size;
+	skb->end  = (unsigned char *) (((unsigned)data + size + 0x0f) & ~0x0f);
+	skb->len = size;
+
+#if defined(CONFIG_BLOG)
+    skb->blog_p = (struct blog_t *)blog_p;
 #endif
+	skb->recycle_hook = recycle_hook;
+	skb->recycle_context = recycle_context;
+	skb->recycle_flags = SKB_RECYCLE | SKB_DATA_RECYCLE;
+
+	atomic_set(&(skb_shinfo(skb)->dataref), 1);
+	skb_shinfo(skb)->nr_frags = 0;
+	skb_shinfo(skb)->gso_size = 0;
+	skb_shinfo(skb)->gso_segs = 0;
+	skb_shinfo(skb)->gso_type = 0;
+	skb_shinfo(skb)->ip6_frag_id = 0;	
+	skb_shinfo(skb)->frag_list = NULL;
+}
+
+static inline void skb_hdrinit(unsigned headroom, unsigned size,
+                        struct sk_buff *skb, unsigned char * data,
+                        RecycleFuncP recycle_hook, unsigned recycle_context)
+{
+	skb_headerinit(headroom, size, skb, data, recycle_hook, recycle_context,
+                 (void*)NULL);	/* No associated Blog object */
+}
+#endif /* 6362 */
+#endif /* CONFIG_MIPS_BCM */
 
 /**
  *	skb_queue_empty - check if a queue is empty
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -272,6 +272,7 @@ static void skb_release_data(struct sk_b
 			skb_drop_fraglist(skb);
 
 #if defined(CONFIG_MIPS_BRCM)
+#ifdef CONFIG_BCM96358
 		/*
 		 * If skb->retfreeq_data_prealloc is 1, that means the data buffer was pre-allocated
 	 	 * by our network driver. (songw)
@@ -281,6 +282,17 @@ static void skb_release_data(struct sk_b
 
 			skb->retfreeq_flags &= ~(SKB_DATA_PREALLOC | SKB_FROM_XMIT_CLEAN);
 		}
+#endif /* 6358 */
+#ifdef CONFIG_BCM96362
+		/*
+		 * If the data buffer came from a preallocated pool, recycle it.
+		 * Recycling may only be performed when no references exist to it.
+		 */
+		if (skb->recycle_hook && (skb->recycle_flags & SKB_DATA_RECYCLE)) {
+			(*skb->recycle_hook)(skb, skb->recycle_context, SKB_DATA_RECYCLE);
+			skb->recycle_flags &= SKB_DATA_NO_RECYCLE;	/* mask out */
+		}
+#endif /* 6362 */
 		else
 #endif
 		kfree(skb->head);
@@ -303,6 +315,7 @@ void kfree_skbmem(struct sk_buff *skb)
 	}
 
 	blog_free(skb);		/* CONFIG_BLOG: Frees associated blog object */
+#ifdef CONFIG_BCM96358
 	/*
 	 * If skb->retfreeq_skb_prealloc is 1, that means the skb was pre-allocated
  	 * by our network driver. (songw)
@@ -310,6 +323,15 @@ void kfree_skbmem(struct sk_buff *skb)
 	if (skb->retfreeq_cb && (skb->retfreeq_flags & SKB_PREALLOC)) {
 		(*skb->retfreeq_cb)(skb->retfreeq_context, skb, RETFREEQ_SKB);
 	}
+#endif /* 6352 */
+#ifdef CONFIG_BCM96362
+	/* If the skb came from a preallocated pool, pass it to recycler hook */
+	if (skb->recycle_hook && (skb->recycle_flags & SKB_RECYCLE)) {
+		(*skb->recycle_hook)(skb, skb->recycle_context, SKB_RECYCLE);
+		// Race condition - the ownership of the sk_buff has already transferred, some driver could be using it. Commenting out the line below.
+		// skb->recycle_flags &= SKB_NO_RECYCLE;	/* mask out. (redundant) */ 
+	}
+#endif /* 6362 */
 	else {
 #endif
 	switch (skb->fclone) {
@@ -489,10 +511,18 @@ struct sk_buff *skb_clone(struct sk_buff
 	C(vtag);
 	C(vtag_save);
 	blog_xfer(n, skb);	/* CONFIG_BLOG: transfers blog ownership */
+#ifdef CONFIG_BCM96358
 	C(retfreeq_flags);
 	n->retfreeq_flags &= ~SKB_PREALLOC;
 	C(retfreeq_cb);
 	C(retfreeq_context);
+#endif /* 6358 */
+#ifdef CONFIG_BCM96362
+	C(recycle_hook);
+	C(recycle_context);
+	n->recycle_flags = skb->recycle_flags & SKB_NO_RECYCLE;
+#endif
+
 	n->extif = NULL;
 
 	if(skb->extif) {
@@ -531,6 +561,11 @@ static void copy_skb_header(struct sk_bu
 	unsigned long offset = new->data - old->data;
 #if defined (CONFIG_MIPS_BRCM)
 	char *extif = NULL;
+#ifdef CONFIG_BCM96362
+	new->recycle_hook = NULL;
+	new->recycle_context = 0U;
+	new->recycle_flags = 0;
+#endif /* 6362 */
 #endif /* CONFIG_MIPS_BRCM */
 
 	new->sk		= NULL;
@@ -578,10 +613,11 @@ static void copy_skb_header(struct sk_bu
 	new->vtag = old->vtag;
 	new->vtag_save = old->vtag_save;
 	blog_xfer(new, old);	/* CONFIG_BLOG: transfers blog ownership */
+#ifdef CONFIG_BCM96358
 	new->retfreeq_cb = NULL;
 	new->retfreeq_context = NULL;
 	new->retfreeq_flags = 0;
-
+#endif /* 6358 */
 	new->extif = NULL;
 
 	if(old->extif) {
@@ -761,12 +797,17 @@ int pskb_expand_head(struct sk_buff *skb
 	skb->h.raw   += off;
 	skb->nh.raw  += off;
 	skb->cloned   = 0;
-#if defined(CONFIG_MIPS_BRCM)
+#ifdef CONFIG_BCM96358
 	/* The data buffer of this skb is not pre-allocated any more
 	 * even the skb itself is pre-allocated. (songw)    
 	 */
 	skb->retfreeq_flags &= ~SKB_DATA_PREALLOC;
-#endif
+#endif /* 6358 */
+#ifdef CONFIG_BCM96362
+	/* The data buffer of this skb is not pre-allocated any more
+	 * even the skb itself is pre-allocated */
+	skb->recycle_flags &= SKB_DATA_NO_RECYCLE;
+#endif /* 6362 */
 	skb->nohdr    = 0;
 	atomic_set(&skb_shinfo(skb)->dataref, 1);
 	return 0;
--- a/include/linux/blog.h
+++ b/include/linux/blog.h
@@ -90,13 +90,62 @@
  *******************************************************************************
  */
 
+
 #include <linux/autoconf.h>
 
 #ifndef NULL_STMT
 #define NULL_STMT                   do { /* NULL BODY */ } while (0)
 #endif
 
+#undef  BLOG_DECL
+#define BLOG_DECL(x)                x,
+
+#ifdef CONFIG_BCM96362
+/* Ethernet phy including Ethernet port used for WANoE */
+#define BCM_EPHY                   (~0)
+
+#define BLOG_ENETPHY                BCM_EPHY
+#define BLOG_NONXTM                 BLOG_ENETPHY
+#else  /* 6358 */
 #define BLOG_NONXTM                 0xFF
+#endif /* 6362 */
+
+
+/*
+ *------------------------------------------------------------------------------
+ * Layer 2 encapsulations logged.
+ * Implementation constraint: max 8 proto types.
+ *  - BCM_XPHY must be 0 (see BLOG_XTMPHY, BLOG_GPONPHY above) (6362)
+ *------------------------------------------------------------------------------
+ */
+typedef enum {
+#ifdef CONFIG_BCM96362
+		BLOG_DECL(BCM_XPHY)         /* e.g. BLOG_XTMPHY, BLOG_GPONPHY */
+#else  /* 6358 */
+        BLOG_DECL(BCM_XTM)          /* BRCM ATM|PTM */
+#endif /* 6362 */
+        BLOG_DECL(BCM_SWC)          /* BRCM Switch Header */
+        BLOG_DECL(ETH_802x)         /* Ethernet */
+        BLOG_DECL(VLAN_8021Q)       /* Vlan 8021Q (incld stacked) */
+        BLOG_DECL(PPPoE_2516)       /* PPPoE RFC 2516 */
+        BLOG_DECL(PPP_1661)         /* PPP RFC 1661 */
+#ifdef CONFIG_BCM96362
+        BLOG_DECL(L3_IPv4)          /* L3 IPv4 */
+        BLOG_DECL(L3_IPv6)          /* L3 IPv6 */
+#else  /* 6358 */
+        BLOG_DECL(USB_CDC11)        /* USB CDC1.1 */
+        BLOG_DECL(WLAN_HDR)         /* WLAN ? */
+#endif /* 6358 */
+        BLOG_DECL(PROTO_MAX)		/* BCM_EPHY is ~0 (6362) */
+} BlogEncap_t;
+
+#ifdef CONFIG_BCM96362
+/* XTM(ATM|PTM) and GPON are examples of miscellaneous BCM_XPHY */
+#define BLOG_XTMPHY                 BCM_XPHY    /* see enum BlogEncap_t */
+#define BLOG_USBPHY                 BCM_XPHY    /* see enum BlogEncap_t */
+#define BLOG_GPONPHY                BCM_XPHY    /* see enum BlogEncap_t */
+#endif /* 6362 */
+
                                             /* First encapsulation type */
 #define TYPE_ETH                    0x0000  /* LAN: ETH, WAN: EoA, MER, PPPoE */
 #define TYPE_PPP                    0x0001  /*           WAN: PPPoA */
@@ -107,9 +156,24 @@
 #define TYPE_ETH_P_8021Q            0x8100  /* VLAN in Ethernet */
 #define TYPE_ETH_P_PPP_SES          0x8864  /* PPPoE in Ethernet */
 #define TYPE_ETH_P_BCM              0x8874  /* BCM Switch Hdr */
+#ifdef CONFIG_BCM96362
+#define TYPE_ETH_P_IPV6             0x86DD  /* IPv6 in Ethernet */
+#define TYPE_ETH_P_8021AD           0x88A8
+#define TYPE_ETH_P_PPP_DIS          0x8863  /* PPPoE Discovery in Ethernet */
+#define TYPE_ETH_P_MPLS_UC          0x8847  /* MPLS Unicast */
+#define TYPE_ETH_P_MPLS_MC          0x8848  /* MPLS Multicast */
+#define TYPE_PPP_IPV6               0x0057  /* IPv6 in PPP */
+#define TYPE_PPP_IPCP               0x8021  /* PPP IP Control Protocol */
+#define TYPE_PPP_LCP                0xC021  /* PPP Link Control Protocol */
+#define TYPE_PPP_MP                 0x003D  /* PPP Multilink Protocol */
+#define TYPE_PPP_IPV6CP             0x8057  /* PPP IPv6 Control Protocol */
+#define TYPE_PPP_MPLSCP             0x80FD  /* PPP MPLS Control Protocol */
+#define TYPE_PPP_MPLS_UC            0x0281  /* PPP MPLS Unicast */
+#define TYPE_PPP_MPLS_MC            0x0283  /* PPP MPLS Multicast */
+#endif /* 6362 */
+
+
 
-#undef  BLOG_DECL
-#define BLOG_DECL(x)                x,
 
 typedef enum {
         BLOG_DECL(PKT_DONE)         /* packet consumed and freed */
@@ -150,14 +214,24 @@ typedef enum {
 // #define CC_CONFIG_BLOG_COLOR
 // #define CC_CONFIG_BLOG_DEBUG
 
+#ifdef CONFIG_BCM96362
+#define BLOG_VERSION                "v2.1"
+#else
 #define BLOG_VERSION                "v1.0"
+#endif /* 6362 */
 
 #define BLOG_ENCAP_MAX              6       /* Maximum number of L2 encaps */
 #define BLOG_HDRSZ_MAX              32      /* Maximum size of L2 encaps */
 
+#ifdef CONFIG_BCM96358
 /* Maximum 400 blogs Ucast+Mcast */
 #define BLOG_EXTEND_SIZE            25      /* Number of Blog_t per extension */
 #define BLOG_EXTEND_MAX             16      /* Maximum extensions allowed */
+#else /* 6362 */
+#define CC_SUPPORT_BLOG_EXTEND              /* Conditional compile            */
+#define BLOG_EXTEND_SIZE_ENGG       25      /* Number of Blog_t per extension */
+#define BLOG_EXTEND_MAX_ENGG        16      /* Maximum extensions allowed     */
+#endif /* 6358 */
 
 #define BLOG_NULL                   ((Blog_t*)NULL)
 
@@ -166,6 +240,21 @@ struct sk_buff;
 struct net_device;
 struct nf_conn;
 struct net_bridge_fdb_entry;
+struct blog_t;
+typedef struct blog_t Blog_t;
+
+#ifdef CONFIG_BCM96362
+/* Support blogging of multicast packets */
+#ifdef CONFIG_BLOG_MCAST
+#define CC_SUPPORT_BLOG_MCAST          1
+#else
+#define CC_SUPPORT_BLOG_MCAST          0
+#endif /* CONFIG_BLOG_MCAST */
+
+struct fkbuff;  /* linux/nbuff.h */
+extern int blog_mcast_g;
+extern void blog_mcast(int enable);
+#endif /* 6362 */
 
 typedef uint16_t hProto_t;
 
@@ -179,46 +268,46 @@ extern const uint8_t rfc2684HdrLength[];
 extern const uint8_t rfc2684HdrData[][16];
 extern const char    * strRfc2684[];    /* for debug printing */
 
-/*
- *------------------------------------------------------------------------------
- * Layer 2 encapsulations logged.
- * Implementation constraint: max 8 proto types.
- *------------------------------------------------------------------------------
- */
-typedef enum {
-        BLOG_DECL(BCM_XTM)          /* BRCM ATM|PTM */
-        BLOG_DECL(BCM_SWC)          /* BRCM Switch Header */
-        BLOG_DECL(ETH_802x)         /* Ethernet */
-        BLOG_DECL(VLAN_8021Q)       /* Vlan 8021Q (incld stacked) */
-        BLOG_DECL(PPPoE_2516)       /* PPPoE RFC 2516 */
-        BLOG_DECL(PPP_1661)         /* PPP RFC 1661 */
-        BLOG_DECL(USB_CDC11)        /* USB CDC1.1 */
-        BLOG_DECL(WLAN_HDR)         /* WLAN ? */
-        BLOG_DECL(PROTO_MAX)
-} BlogEncap_t;
-
 
 typedef struct {
     uint8_t             channel;        /* e.g. port number, txchannel, ... */
     uint8_t             count;          /* Number of L2 encapsulations */
 
     struct {
+#ifdef CONFIG_BCM96362
+        uint8_t             hw_support  :1;     /* e.g. hw acceleration */
+#else /* 6358 */
         uint8_t             reserved    :2;
+#endif /* 6362 */
         uint8_t             qdisc       :1;        /* traffic control flag */
         uint8_t             multicast   :1;        /* multicast flag */
+#ifdef CONFIG_BCM96362
+        uint8_t             tunnel      :1;     /* Tunneling 4in6 or 6in4 */
+        uint8_t             phyHdr      :4;     /* e.g. Rfc2684_t hdr type */
+#else /* 6358 */
         uint8_t             rfc2684     :4;        /* Type of rfc2684 header */
+#endif /* 6362 */
     };
 
     union {
         struct {
+#ifdef CONFIG_BCM96362
+            uint8_t         L3_IPv6     : 1;
+            uint8_t         L3_IPv4     : 1;
+#else /* 6358 */
             uint8_t         WLAN_HDR    : 1;
             uint8_t         USB_CDC11   : 1;
+#endif /* 6362 */
             uint8_t         PPP_1661    : 1;
             uint8_t         PPPoE_2516  : 1;
             uint8_t         VLAN_8021Q  : 1;    /* also 8021Qad stacked */
             uint8_t         ETH_802x    : 1;
             uint8_t         BCM_SWC     : 1;
+#ifdef CONFIG_BCM96362
+            uint8_t         BCM_XPHY    : 1;    /* e.g. BCM_XTM */
+#else /* 6358 */
             uint8_t         BCM_XTM     : 1;    /* ATM/PTM type  */
+#endif /* 6362 */
         }               bmap;/* as per order of BlogEncap_t enums declaration */
         uint8_t         hdrs;
     };
@@ -249,6 +338,44 @@ struct blogTuple_t {
 } __attribute__((packed)) ____cacheline_aligned;
 typedef struct blogTuple_t BlogTuple_t;
 
+#if defined(CONFIG_BLOG_IPV6) && defined(CONFIG_BCM96362)
+typedef struct ip6_addr {
+    union {
+        uint8_t     p8[16];
+        uint16_t    p16[8];
+        uint32_t    p32[4];
+    };
+} ip6_addr_t;
+
+/*
+ *------------------------------------------------------------------------------
+ * Buffer to log IPv6 Tuple.
+ *------------------------------------------------------------------------------
+ */
+struct blogTupleV6_t {
+
+    ip6_addr_t      saddr;
+    ip6_addr_t      daddr;
+
+    union {
+        struct {
+            uint16_t    source;     /* L4 source port */
+            uint16_t    dest;       /* L4 dest port */
+        }           port;
+        uint32_t    ports;
+    };
+
+    uint8_t         hop_limit;      /* IPv6 header hop limit (ttl) */
+    uint8_t         priority;       /* IPv6 header traffic class (tos) */
+    uint16_t        exthdr_map;     /* Bit field of IPv6 extension headers */
+
+    uint32_t        reserved[2];    /* padding */
+} __attribute__((packed)) ____cacheline_aligned;
+typedef struct blogTupleV6_t BlogTupleV6_t;
+
+#endif  /* defined(CONFIG_BLOG_IPV6) && defined(CONFIG_BCM96362) */
+
+
 /*
  *------------------------------------------------------------------------------
  * Buffer to log Layer 2 and IP Tuple headers.
@@ -282,6 +409,24 @@ struct blogHeader_t {
 
 typedef struct blogHeader_t BlogHeader_t;           /* L2 and L3+4 tuple */
 
+#ifdef CONFIG_BCM96362
+/* Coarse key: L1, L3, L4 hash */
+union blogKey_t {
+    uint32_t        match;
+    struct {
+        uint8_t     hash;               /* Hash of Rx IP tuple */
+        uint8_t     protocol;           /* IP protocol */
+
+        struct {
+            uint8_t channel;
+            uint8_t phy;
+        } l1_tuple;
+    };
+} __attribute__((packed));
+
+typedef union blogKey_t BlogKey_t;
+#endif /* 6362 */
+
 /*
  *------------------------------------------------------------------------------
  * Buffer log structure.
@@ -295,11 +440,13 @@ struct blog_t {
         struct blog_t   * blog_p;       /* Free list of Blog_t */
         struct sk_buff  * skb_p;        /* Associated sk_buff */
     };
-
+#ifdef CONFIG_BCM96362
+    BlogKey_t           key;            /* Coarse search key */
+#else /* 6358 */
     uint8_t             hash;           /* Hash of Rx IP tuple */
     uint8_t             protocol;       /* IP protocol */
     uint16_t            nfct_events;    /* netfilter events */
-
+#endif /* 6362 */
     uint32_t            mark;           /* NF mark value on tx */
     uint32_t            priority;       /* Tx  priority */
 
@@ -310,10 +457,14 @@ struct blog_t {
     BlogHeader_t        rx;             /* Receive path headers */
     BlogHeader_t        tx;             /* Transmit path headers */
 
+#if defined(CONFIG_BLOG_IPV6) && defined(CONFIG_BCM96362)
+    BlogTupleV6_t       tupleV6;        /* L3+L4 IP Tuple log */
+#endif
+
 } __attribute__((packed)) ____cacheline_aligned;
-typedef struct blog_t Blog_t;
 
 
+#ifdef CONFIG_BCM96358
 /*
  * -----------------------------------------------------------------------------
  *
@@ -332,6 +483,30 @@ typedef struct blog_t Blog_t;
  */
 typedef BlogAction_t (* BlogHook_t)(struct sk_buff * skb_p, Blog_t * blog_p,
                                     uint16_t encap);
+#else /* 6362 */
+/*
+ * -----------------------------------------------------------------------------
+ *
+ * Blog defines three hooks:
+ *
+ *  RX Hook: If this hook is defined then blog_init() will pass the packet to
+ *           the Rx Hook using the FkBuff_t context. L1 and encap information
+ *           are passed to the receive hook. The private network device context 
+ *           may be extracted using the passed net_device object, if needed.
+ *
+ *  TX Hook: If this hook is defined then blog_emit() will check to see whether
+ *           the NBuff has a Blog_t, and if so pass the NBuff and Blog to the
+ *           bound Tx hook.
+ *
+ *  StopHook: When blog_stop is invoked, the bound hook is invoked.
+ *           Use of Stop hook, to stop associated traffic flow when a conntrack
+ *           is destroyed. 
+ *
+ * -----------------------------------------------------------------------------
+ */
+typedef BlogAction_t (* BlogHook_t)(void * fkb_skb_p, struct net_device * dev_p,
+                                    uint32_t encap, uint32_t blogKey);
+#endif /* 6358 */
 typedef void (* BlogStop_t)(struct net_bridge_fdb_entry * fdb_p,
                             struct nf_conn * ct_p );
 
@@ -345,6 +520,7 @@ extern void blog_bind(BlogHook_t rx_hook
  * -----------------------------------------------------------------------------
  */
 
+
 /* Free a Blog_t */
 void blog_put(Blog_t * blog_p);
 
@@ -380,6 +556,14 @@ extern void blog_xfer(struct sk_buff * s
  */
 extern void blog_clone(struct sk_buff * skb_p, const struct blog_t * prev_p);
 
+#ifdef CONFIG_BCM96362
+extern Blog_t * blog_fkb(struct fkbuff  * fkb_p);
+
+/* Clear association of Blog_t with sk_buff */
+extern Blog_t * blog_snull(struct sk_buff * skb_p);
+extern Blog_t * blog_fnull(struct fkbuff  * fkb_p);
+extern void blog_move(struct sk_buff * skb_p, struct fkbuff * fkb_p);
+#endif /* 6362 */
 /*
  *------------------------------------------------------------------------------
  * BLOG to Netfilter Conntrack interface for flows tracked by Netfilter.
@@ -392,7 +576,9 @@ extern void blog_clone(struct sk_buff *
 
 /* Log a Netfilter Conntrack and events into a blog on nf_conntrack_in */
 extern void blog_nfct(struct sk_buff * skb_p, struct nf_conn * nfct_p);
+#ifdef CONFIG_BCM6352
 extern void blog_ctev(const struct sk_buff * skb_p, uint16_t event);
+#endif /* 6352 */
 
 /* Log a bridge forward info into a blog at br_handle_frame_finish */
 extern void blog_br_fdb(struct sk_buff * skb_p, 
@@ -410,7 +596,9 @@ extern void blog_stop(struct net_bridge_
                       struct nf_conn * nfct_p);
 
 /* Refresh a blogged conntrack on behalf of associated traffic flow */
+#ifdef CONFIG_NETFILTER
 extern void blog_time(Blog_t * blog_p, uint32_t jiffies);
+#endif
 typedef void (*blog_refresh_t)(struct nf_conn * nfct, uint32_t ctinfo,
                                struct sk_buff * skb_p,
                                uint32_t jiffies, int do_acct);
@@ -419,6 +607,7 @@ extern blog_refresh_t blog_refresh_fn;
 /* Refresh a blogged bridge forward entry on behalf of associated flow */
 extern void blog_refresh_br( Blog_t * blog_p );
 
+#ifdef CONFIG_BCM96358
 /*
  *------------------------------------------------------------------------------
  * If rx hook is defined, allocate and associate a Blog_t object with the
@@ -435,7 +624,30 @@ extern BlogAction_t blog_init(struct sk_
  */
 extern BlogAction_t blog_emit(struct sk_buff * skb_p, struct net_device * dev_p,
                               uint32_t channel, uint8_t xtmHdr, uint16_t encap);
+#else /* 6362 */
+/*
+ *------------------------------------------------------------------------------
+ * If rx hook is defined,
+ *  blog_sinit(): initialize a fkb from skb, and pass to hook
+ *          if packet is consumed, skb is released.
+ *          if packet is blogged, the blog from fkb is transferred to skb.
+ *  blog_finit(): pass to hook
+ *          if packet is to be blogged, the blog is associated with fkb.
+ *------------------------------------------------------------------------------
+ */
+extern BlogAction_t blog_sinit(struct sk_buff *skb_p, struct net_device * dev_p,
+                             uint32_t encap, uint32_t channel, uint32_t phyHdr);
+extern BlogAction_t blog_finit(struct fkbuff *fkb_p, struct net_device * dev_p,
+                             uint32_t encap, uint32_t channel, uint32_t phyHdr);
 
+/*
+ *------------------------------------------------------------------------------
+ * If tx hook is defined, invoke tx hook, dis-associate and free Blog_t
+ *------------------------------------------------------------------------------
+ */
+extern BlogAction_t blog_emit(void * nbuff_p, struct net_device * dev_p,
+                             uint32_t encap, uint32_t channel, uint32_t phyHdr);
+#endif /* 6358 */
 /* Logging of L2|L3 headers */
 extern void blog(struct sk_buff * skb_p, BlogDir_t dir, BlogEncap_t encap,  
                  size_t len, void * data_p);
@@ -452,31 +664,31 @@ extern const char * strBlogEncap[];
 
 #else   /* else ! defined(CONFIG_BLOG) */
 
+#ifdef CONFIG_BCM96358
 #define blog_put(blog)                          NULL_STMT
 #define blog_skb(skb)                           NULL
 #define blog_free(skb)                          NULL_STMT
 #define blog_dump(blog)                         NULL_STMT
 #define blog_skip(skb)                          NULL_STMT
-
 #define blog_null(skb)                          NULL
 #define blog_link(skb, blog)                    NULL_STMT
 #define blog_xfer(skb, prev)                    NULL_STMT
 #define blog_clone(skb, prev)                   NULL_STMT
-
-#define blog_nfct(skb, nfct)                    NULL_STMT
 #define blog_ctev(skb, event)                   NULL_STMT
+#define blog_hash(blog)                         NULL_STMT
+#define blog_init(skb, dev, ch, xtm, encap)     PKT_NORM
+#define blog_emit(skb, dev, ch, xtm, encap)     NULL_STMT
+#define blog(skb, dir, encap, len, hdr)         NULL_STMT
+#endif /* 6358 */
+#define blog_nfct(skb, nfct)                    NULL_STMT
 #define blog_refresh_br(blog)                   NULL_STMT
 #define blog_br_fdb(skb, fdb_src, fdb_dst)      NULL_STMT
 #define blog_flow(blog, key)                    NULL_STMT
 #define blog_stop(fdb,nfct)                     NULL_STMT
+#ifdef CONFIG_NETFILTER
 #define blog_time(blog, time)                   NULL_STMT
+#endif
 
-#define blog_hash(blog)                         NULL_STMT
-
-#define blog_init(skb, dev, ch, xtm, encap)     PKT_NORM
-#define blog_emit(skb, dev, ch, xtm, encap)     NULL_STMT
-
-#define blog(skb, dir, encap, len, hdr)         NULL_STMT
 #define BLOG(skb, dir, encap, len, hdr)         NULL_STMT
 
 #define blog_bind(rx_hook, tx_hook, stop_hook)  NULL_STMT
--- a/net/core/blog.c
+++ b/net/core/blog.c
@@ -28,6 +28,11 @@
  */
 
 #include <linux/init.h>
+#ifdef CONFIG_BCM96362
+#include <linux/nbuff.h>
+#include <linux/module.h>
+#endif /* 6362 */
+#if defined(CONFIG_BLOG)
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 #include <linux/slab.h>
@@ -39,8 +44,10 @@
 #include <linux/tcp.h>
 #include <linux/udp.h>
 #include <net/ip.h>
+#ifdef CONFIG_NETFILTER
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_helper.h>
+#endif
 #include "../bridge/br_private.h"
 
 #ifdef CC_CONFIG_BLOG_COLOR
@@ -84,6 +91,10 @@
 
 /*--- globals ---*/
 
+#ifdef CONFIG_BCM96362
+int blog_mcast_g = CC_SUPPORT_BLOG_MCAST;
+void blog_mcast(int enable) { blog_mcast_g = enable; }
+#endif /* 6362 */
 /*
  * Traffic flow generator, keep conntrack alive during idle traffic periods
  * by refreshing the conntrack. Dummy sk_buff passed to nf_conn.
@@ -102,14 +113,23 @@ const char * strBlogAction[] =
 
 const char * strBlogEncap[] =
 {
+#ifdef CONFIG_BCM96362
+    BLOG_DECL(BCM_XPHY)
+#else /* 6358 */
     BLOG_DECL(BCM_XTM)
+#endif /* 6362 */
     BLOG_DECL(BCM_SWC)
     BLOG_DECL(ETH_802x)
     BLOG_DECL(VLAN_8021Q)
     BLOG_DECL(PPPoE_2516)
     BLOG_DECL(PPP_1661)
+#ifdef CONFIG_BCM96362
+    BLOG_DECL(L3_IPv4)
+    BLOG_DECL(L3_IPv6)
+#else /* 6358 */
     BLOG_DECL(USB_CDC11)
     BLOG_DECL(WLAN_TBD)
+#endif /* 6362 */
     BLOG_DECL(PROTO_MAX)
 };
 
@@ -135,6 +155,7 @@ const char * strIpctStatus[] =  /* in re
     BLOG_DECL(BLOG)
 };
 
+#ifdef CONFIG_BCM96358
 const char * strIpctEvents[] =  /* in reference to enum ip_conntrack_events */
 { 
     BLOG_DECL(NEW)
@@ -183,7 +204,7 @@ const char * ct_evtname(uint32_t evt_val
 #else
 #define ct_evtname(evt)       "ct_event"
 #endif
-
+#endif /* 6358 */
 /*
  *------------------------------------------------------------------------------
  * Support for RFC 2684 headers logging.
@@ -201,6 +222,7 @@ const char * strRfc2684[] =
         BLOG_DECL(PTM)                  /*                               */
 };
 
+/* CAUTION: Currently only XTM type special phy's use BlogInfo_t::phyHdr */
 const uint8_t rfc2684HdrLength[] =
 {
      0, /* header was already stripped. :                               */
@@ -239,6 +261,16 @@ static BlogStop_t blog_xx_hook_g = (Blog
  * Network Utilities  : Network Order IP Address access (in Big Endian) format
  *------------------------------------------------------------------------------
  */
+#ifdef CONFIG_BCM96362
+#define _IPFMT_                 "<%03u.%03u.%03u.%03u>"
+#define _IPPFMT_                "<%03u.%03u.%03u.%03u:%u>"
+#define _IP6FMT_                "<%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x>"
+#define _IP6PFMT_               "<%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x:%u>"
+#define _IP6_(ip)               ((uint16_t*)&ip)[0], ((uint16_t*)&ip)[1],   \
+                                ((uint16_t*)&ip)[2], ((uint16_t*)&ip)[3],   \
+                                ((uint16_t*)&ip)[4], ((uint16_t*)&ip)[5],   \
+                                ((uint16_t*)&ip)[6], ((uint16_t*)&ip)[7]
+#endif /* 6362 */
 #define _IP_(ip)                ((uint8_t*)&ip)[0], ((uint8_t*)&ip)[1], \
                                 ((uint8_t*)&ip)[2], ((uint8_t*)&ip)[3]
 
@@ -319,10 +351,19 @@ static uint32_t blog_construct( uint32_t
     for ( i = 0; i < num; i++ )
         list_p[i].blog_p = &list_p[i+1];
 
+#ifdef CONFIG_BCM96362
+    local_irq_disable();
+#else
     local_bh_disable();
+#endif /* 6362 */
     list_p[num-1].blog_p = blog_list_gp; /* chain last Blog_t object */
     blog_list_gp = list_p;  /* Head of list */
+#ifdef CONFIG_BCM96362
+    local_irq_enable();
+#else
     local_bh_enable();
+#endif /* 6362 */
+
 
     BLOG_DBG( blog_cnt_free += num; );
 
@@ -342,11 +383,19 @@ static inline void blog_clr( Blog_t * bl
     /* clear rfc2684, count, bmap, and channel */
     blog_p->rx.word = 0;
     blog_p->tx.word = 0;
-
+#ifdef CONFIG_BCM96362
+    blog_p->key.match = 0;    /* clears hash, protocol, l1_tuple */
+    blog_p->tx.dev_p = (struct net_device *)NULL;
+#else
     blog_p->nfct_events = 0;
+#endif /* 6362 */
     blog_p->rx.ct_p = (struct nf_conn*)NULL;
     blog_p->fdb_src = (struct net_bridge_fdb_entry*)NULL;
     blog_p->fdb_dst = (struct net_bridge_fdb_entry*)NULL;
+
+#ifdef CONFIG_BCM96362
+    blog_print( "blog<0x%08x>", (int)blog_p );
+#endif /* 6362 */
 }
 
 /*
@@ -356,6 +405,7 @@ static inline void blog_clr( Blog_t * bl
  * Returns      : Pointer to an Blog_t or NULL, on depletion.
  *------------------------------------------------------------------------------
  */
+#ifdef CONFIG_BCM96358
 static Blog_t * blog_get( void )
 {
     register Blog_t * blog_p;
@@ -392,7 +442,46 @@ static Blog_t * blog_get( void )
 
     return blog_p;
 }
+#else /* 6362 */
+static Blog_t * blog_get( void )
+{
+    register Blog_t * blog_p;
+
+    if ( blog_list_gp == BLOG_NULL )
+    {
+#ifdef CC_SUPPORT_BLOG_EXTEND
+        if ( (blog_extends >= BLOG_EXTEND_MAX_ENGG)/* Try extending free pool */
+          || (blog_construct( BLOG_EXTEND_SIZE_ENGG ) != BLOG_EXTEND_SIZE_ENGG))
+        {
+            blog_print( "WARNING: free list exhausted" );
+            return BLOG_NULL;
+        }
+#else
+        if ( blog_construct( BLOG_EXTEND_SIZE_ENGG ) == 0 )
+        {
+            blog_print( "WARNING: out of memory" );
+            return BLOG_NULL;
+        }
+#endif
+    }
+    BLOG_DBG(
+        blog_cnt_free--;
+        if ( ++blog_cnt_used > blog_cnt_hwm )
+            blog_cnt_hwm = blog_cnt_used;
+        );
+
+    local_irq_disable();
+    blog_p = blog_list_gp;
+    blog_list_gp = blog_list_gp->blog_p;
+    local_irq_enable();
+
+    blog_clr( blog_p );     /* quickly clear the contents */
 
+    blog_print( "blog<0x%08x>", (int)blog_p );
+
+    return blog_p;
+}
+#endif /* 6358 */
 /*
  *------------------------------------------------------------------------------
  * Function     : blog_put
@@ -406,10 +495,20 @@ void blog_put( Blog_t * blog_p )
     blog_assertv( (blog_p != BLOG_NULL) );
     BLOG_DBG( blog_cnt_used--; blog_cnt_free++; );
     blog_clr( blog_p );
+#ifdef CONFIG_BCM96362
+    local_irq_disable();
+#else /* 6358 */
     local_bh_disable();
+#endif /* 6362 */
     blog_p->blog_p = blog_list_gp;
     blog_list_gp = blog_p;  /* link into free pool */
+#ifdef CONFIG_BCM96362
+    local_irq_enable();
+
+    blog_print( "blog<0x%08x>", (int)blog_p );
+#else /* 6358 */
     local_bh_enable();
+#endif /* 6362 */
 }
 
 /*
@@ -426,9 +525,79 @@ Blog_t * blog_skb( struct sk_buff * skb_
     blog_assertr( (skb_p != (struct sk_buff *)NULL), BLOG_NULL );
     blog_assertr( (skb_p->blog_p == BLOG_NULL), BLOG_NULL );
     skb_p->blog_p = blog_get(); /* Allocate and associate with skb */
+#ifdef CONFIG_BCM96362
+    blog_print( "skb<0x%08x> blog<0x%08x>", (int)skb_p, (int)skb_p->blog_p );
+#endif /* 6362 */
     return skb_p->blog_p;       /* May be null */
 }
 
+#ifdef CONFIG_BCM96362
+/*
+ *------------------------------------------------------------------------------
+ * Function     : blog_fkb
+ * Description  : Allocate and associate a Blog_t with an fkb.
+ * Parameters   :
+ *  fkb_p       : pointer to a non-null FkBuff_t
+ * Returns      : A Blog_t object or NULL,
+ *------------------------------------------------------------------------------
+ */
+Blog_t * blog_fkb( struct fkbuff * fkb_p )
+{
+    blog_assertr( (fkb_p != (FkBuff_t *)NULL), BLOG_NULL );
+    blog_assertr( (fkb_p->blog_p == BLOG_NULL), BLOG_NULL );
+    fkb_p->blog_p = blog_get(); /* Allocate and associate with fkb */
+    blog_print( "fkb<0x%08x> blog<0x%08x>", (int)fkb_p, (int)fkb_p->blog_p );
+    return fkb_p->blog_p;       /* May be null */
+}
+
+/*
+ *------------------------------------------------------------------------------
+ * Function     : blog_snull
+ * Description  : Dis-associate a sk_buff with any Blog_t
+ * Parameters   :
+ *  skb_p       : Pointer to a non-null sk_buff
+ * Returns      : Previous Blog_t associated with sk_buff
+ *------------------------------------------------------------------------------
+ */
+inline Blog_t * _blog_snull( struct sk_buff * skb_p )
+{
+    register Blog_t * blog_p;
+    blog_p = skb_p->blog_p;
+    skb_p->blog_p = BLOG_NULL;
+    return blog_p;
+}
+
+Blog_t * blog_snull( struct sk_buff * skb_p )
+{
+    blog_assertr( (skb_p != (struct sk_buff *)NULL), BLOG_NULL );
+    blog_print( "skb<0x%08x> blogp<0x%08x>", (int)skb_p, (int)skb_p->blog_p );
+    return _blog_snull( skb_p );
+}
+
+/*
+ *------------------------------------------------------------------------------
+ * Function     : blog_fnull
+ * Description  : Dis-associate a fkbuff with any Blog_t
+ * Parameters   :
+ *  fkb_p       : Pointer to a non-null fkbuff
+ * Returns      : Previous Blog_t associated with fkbuff
+ *------------------------------------------------------------------------------
+ */
+inline Blog_t * _blog_fnull( struct fkbuff * fkb_p )
+{
+    register Blog_t * blog_p;
+    blog_p = fkb_p->blog_p;
+    fkb_p->blog_p = BLOG_NULL;
+    return blog_p;
+}
+
+Blog_t * blog_fnull( struct fkbuff * fkb_p )
+{
+    blog_assertr( (fkb_p != (struct fkbuff *)NULL), BLOG_NULL );
+    blog_print( "fkb<0x%08x> blogp<0x%08x>", (int)fkb_p, (int)fkb_p->blog_p );
+    return _blog_fnull( fkb_p );
+}
+#else /* 6358 */
 /*
  *------------------------------------------------------------------------------
  * Function     : blog_null
@@ -451,7 +620,7 @@ Blog_t * blog_null( struct sk_buff * skb
     blog_assertr( (skb_p != (struct sk_buff *)NULL), BLOG_NULL );
     return _blog_null( skb_p );
 }
-
+#endif /* 6362 */
 /*
  *------------------------------------------------------------------------------
  * Function     : blog_free
@@ -463,7 +632,11 @@ Blog_t * blog_null( struct sk_buff * skb
 inline void _blog_free( struct sk_buff * skb_p )
 {
     register Blog_t * blog_p;
+#ifdef CONFIG_BCM96362
+    blog_p = _blog_snull( skb_p );   /* Dis-associate Blog_t from skb_p */
+#else /* 6358 */
     blog_p = _blog_null( skb_p );   /* Dis-associate Blog_t from skb_p */
+#endif /* 6362 */
     if ( likely(blog_p != BLOG_NULL) )
         blog_put( blog_p );         /* Recycle blog_p into free list */
 }
@@ -471,6 +644,13 @@ inline void _blog_free( struct sk_buff *
 void blog_free( struct sk_buff * skb_p )
 {
     blog_assertv( (skb_p != (struct sk_buff *)NULL) );
+#ifdef CONFIG_BCM96362
+    BLOG_DBG(
+        if ( skb_p->blog_p != BLOG_NULL )
+            blog_print( "skb<0x%08x> blog<0x%08x> [<0x%08x>]",
+                        (int)skb_p, (int)skb_p->blog_p,
+                        (int)__builtin_return_address(0) ); );
+#endif /* 6362 */
     _blog_free( skb_p );
 }
 
@@ -485,7 +665,8 @@ void blog_free( struct sk_buff * skb_p )
  */
 void blog_skip( struct sk_buff * skb_p )
 {
-    blog_print( "[<0x%08x>]", (int)__builtin_return_address(0) );
+    blog_print( "skb<0x%08x> [<0x%08x>]",
+                (int)skb_p, (int)__builtin_return_address(0) );
     blog_assertv( (skb_p != (struct sk_buff *)NULL) );
     _blog_free( skb_p );
 }
@@ -504,6 +685,9 @@ void blog_link( struct sk_buff * skb_p,
     blog_assertv( (blog_p != BLOG_NULL) );
     blog_assertv( (skb_p != (struct sk_buff *)NULL) );
     blog_assertv( (skb_p->blog_p == BLOG_NULL) );  /* Avoid leak */
+#ifdef CONFIG_BCM96362
+    blog_print( "skb<0x%08x> blog<0x%08x>", (int)skb_p, (int)blog_p );
+#endif /* 6362 */
     skb_p->blog_p = blog_p;
 }
 
@@ -524,29 +708,70 @@ void blog_xfer( struct sk_buff * skb_p,
     blog_assertv( (skb_p != (struct sk_buff *)NULL) );
 
     mod_prev_p = (struct sk_buff *) prev_p; /* const removal without warning */
+#ifdef CONFIG_BCM96362
+    blog_p = _blog_snull( mod_prev_p );
+#else /* 6358 */
     blog_p = _blog_null( mod_prev_p );
+#endif /* 6362 */
     skb_p->blog_p = blog_p;
 
     if ( likely(blog_p != BLOG_NULL) )
     {
+#ifdef CONFIG_BCM96362
+        blog_print( "skb<0x%08x> to new<0x%08x> blog<0x%08x> [<0x%08x>]",
+                    (int)prev_p, (int)skb_p, (int)blog_p,
+                    (int)__builtin_return_address(0) );
+#else /* 6358 */
         blog_print( "skb<0x%08x> to new<0x%08x> blog<0x%08x>",
                     (int)prev_p, (int)skb_p, (int)blog_p );
+#endif /* 6362 */
+        blog_p->skb_p = skb_p;
+    }
+}
+
+#ifdef CONFIG_BCM96362
+/*
+ *------------------------------------------------------------------------------
+ * Function     : blog_move
+ * Description  : Transfer ownership of a Blog_t from fkb to skb.
+ * Parameters   :
+ *  skb_p       : New owner of Blog_t object
+ *  fkb_p       : Former owner of Blog_t object
+ *------------------------------------------------------------------------------
+ */
+void blog_move( struct sk_buff * skb_p, struct fkbuff * fkb_p )
+{
+    Blog_t * blog_p;
+    blog_assertv( (skb_p != (struct sk_buff *)NULL) );
+    blog_assertv( (fkb_p != (struct fkbuff *)NULL) );
+
+    blog_p = _blog_fnull( fkb_p );
+    skb_p->blog_p = blog_p;
+
+    if ( likely(blog_p != BLOG_NULL) )
+    {
+        blog_print( "fkb<0x%08x> to skb<0x%08x> blog<0x%08x> [<0x%08x>]",
+                    (int)fkb_p, (int)skb_p, (int)blog_p,
+                    (int)__builtin_return_address(0) );
         blog_p->skb_p = skb_p;
     }
 }
+#endif /* 6362 */
 
 /*
  *------------------------------------------------------------------------------
  * Function     : blog_clone
  * Description  : Duplicate a Blog_t for another sk_buff
  * Parameters   :
- *  skb_p       : New owner of Blog_t object 
+ *  skb_p       : New owner of cloned Blog_t object 
  *  prev_p      : Blog_t object to be cloned
  *------------------------------------------------------------------------------
  */
 void blog_clone( struct sk_buff * skb_p, const struct blog_t * prev_p )
 {
+#ifdef CONFIG_BCM96358
     blog_assertv( (prev_p != (struct blog_t *)NULL) );
+#endif /* 6358 */
     blog_assertv( (skb_p != (struct sk_buff *)NULL) );
 
     if ( likely(prev_p != BLOG_NULL) )
@@ -556,16 +781,25 @@ void blog_clone( struct sk_buff * skb_p,
         skb_p->blog_p = blog_get(); /* Allocate and associate with skb */
         blog_p = skb_p->blog_p;
 
+#ifdef CONFIG_BCM96362
+        blog_print( "orig blog<0x%08x> new skb<0x%08x> blog<0x%08x> [<0x%08x>]",
+                    (int)prev_p, (int)skb_p, (int)blog_p,
+                    (int)__builtin_return_address(0) );
+#else /* 6358 */
         blog_print( "orig blog<0x%08x> duplicate to" 
                     " new skb<0x%08x> with new blog<0x%08x>",
                     (int)prev_p, (int)skb_p, (int)blog_p );
-
+#endif /* 6362 */
         if ( likely(blog_p != BLOG_NULL) )
         {
             blog_p->skb_p = skb_p;
 #define CPY(x) blog_p->x = prev_p->x
+#ifdef CONFIG_BCM96362
+            CPY(key.match);
+#else /* 6358 */
             CPY(hash);
             CPY(protocol);
+#endif /* 6362 */ 
             CPY(mark);
             CPY(priority);
             CPY(rx);
@@ -598,17 +832,25 @@ void blog_nfct( struct sk_buff * skb_p,
     if ( unlikely(skb_p->blog_p->rx.info.multicast) )
         return;
 
+#ifdef CONFIG_BCM96362
+    blog_print( "skb<0x%08x> blog<0x%08x> nfct<0x%08x> [<0x%08x>]",
+                (int)skb_p, (int)skb_p->blog_p, (int)ct_p,
+                (int)__builtin_return_address(0) );
+#else /* 6358 */
     blog_print( "skb<0x%08x> blog<0x%08x> nfct<0x%08x>",
                 (int)skb_p, (int)skb_p->blog_p, (int)ct_p );
+#endif /* 6362 */
 
     skb_p->blog_p->rx.ct_p = ct_p;                  /* Pointer to conntrack */
+#ifdef CONFIG_BCM96358
     skb_p->blog_p->nfct_events = IPCT_BLOG;         /* Blogged conntrack */
-
+#endif
     ct = nf_ct_get(skb_p, &ctinfo);
     blog_assertv( (ct == ct_p) );
     skb_p->blog_p->rx.nf_dir = CTINFO2DIR(ctinfo);  /* Conntrack direction */
 }
 
+#ifdef CONFIG_BCM96358
 /*
  *------------------------------------------------------------------------------
  * Function     : blog_ctev [Down call from Netfilter]
@@ -636,6 +878,7 @@ void blog_ctev( const struct sk_buff * s
 
     ((struct sk_buff *)skb_p)->blog_p->nfct_events |= (uint16_t)nfct_event;
 }
+#endif /* 6358 */
 
 /*
  *------------------------------------------------------------------------------
@@ -650,6 +893,11 @@ void blog_flow( Blog_t * blog_p, uint32_
 {
     blog_assertv( (blog_p != BLOG_NULL) );
     blog_assertv( (blog_p->rx.ct_p != (struct nf_conn*)NULL) );
+#ifdef CONFIG_BCM96362
+    blog_print( "blog<0x%08x> ct<0x%08x> key<%u> [<0x%08x>]",
+                (int)blog_p, (int)blog_p->rx.ct_p, key,
+                (int)__builtin_return_address(0) );
+#endif
 
     blog_p->rx.ct_p->blog_key[ blog_p->rx.nf_dir ] = key;
 }
@@ -674,9 +922,15 @@ void blog_br_fdb( struct sk_buff * skb_p
 
     if ( unlikely(skb_p->blog_p == BLOG_NULL) )
         return;
-
+#ifdef CONFIG_BCM6358
     blog_print( "skb<0x%08x> blog<0x%08x> fdb_src<0x%08x> fdb_dst<0x%08x>",
                 (int)skb_p, (int)skb_p->blog_p, (int)fdb_src, (int)fdb_dst );
+#else /* 6362 */
+    blog_print("skb<0x%08x> blog<0x%08x> fdb_src<0x%08x> fdb_dst<0x%08x>"
+               " [<0x%08x>]",
+               (int)skb_p, (int)skb_p->blog_p, (int)fdb_src, (int)fdb_dst,
+               (int)__builtin_return_address(0) );
+#endif /* 6358 */
 
     skb_p->blog_p->fdb_src = fdb_src;      /* Pointer to net_bridge_fdb_entry */
     skb_p->blog_p->fdb_dst = fdb_dst;      /* Pointer to net_bridge_fdb_entry */
@@ -706,6 +960,8 @@ void blog_stop( struct net_bridge_fdb_en
     }
 }
 
+
+#ifdef CONFIG_NETFILTER
 /*
  *------------------------------------------------------------------------------
  * Function     : blog_time [Up call to Netfilter]
@@ -723,7 +979,7 @@ void blog_time( Blog_t * blog_p, uint32_
         (*blog_refresh_fn)( blog_p->rx.ct_p, 0, nfskb_p, jiffies, 0 );
     }
 }
-
+#endif
 /*
  *------------------------------------------------------------------------------
  * Function     : blog_refresh_br [Up call to bridge]
@@ -738,7 +994,7 @@ void blog_refresh_br( Blog_t * blog_p )
         br_fdb_refresh( blog_p->fdb_src );
 
 }
-
+#ifdef CONFIG_BCM96358
 /*
  *------------------------------------------------------------------------------
  * Function     : blog_init
@@ -813,7 +1069,73 @@ BlogAction_t blog_init( struct sk_buff *
 pkt_norm:
     return PKT_NORM;                    /* continue normal stack processing */
 }
+#else /* 6362 */
+/*
+ *------------------------------------------------------------------------------
+ * Function     : blog_finit, blog_sinit
+ * Description  : This function may be inserted in a physical network device's
+ *                packet receive handler. A receive handler typically extracts
+ *                the packet data from the rx DMA buffer ring, allocates and
+ *                sets up a sk_buff, decodes the l2 headers and passes the
+ *                sk_buff into the network stack via netif_receive_skb/netif_rx.
+ *
+ *                Prior to constructing a sk_buff, blog_finit() may be invoked
+ *                using a fast kernel buffer to carry the received buffer's
+ *                context <data,len>, and the receive net_device and l1 info.
+ *
+ *                This function invokes the bound receive blog hook.
+ *
+ * Parameters   :
+ *  blog_finit() fkb_p: Pointer to a fast kernel buffer<data,len>
+ *  blog_sinit() skb_p: Pointer to a Linux kernel skbuff
+ *  dev_p       : Pointer to the net_device on which the packet arrived.
+ *  encap       : First encapsulation type
+ *  channel     : Channel/Port number on which the packet arrived.
+ *  phyHdr      : e.g. XTM device RFC2684 header type
+ *
+ * Returns      :
+ *  PKT_DONE    : The fkb is consumed and device should not process skb_p.
+ *  PKT_NORM    : Device may invoke netif_receive_skb for normal processing.
+ *  PKT_BLOG    : PKT_NORM behaviour + Blogging enabled.
+ *
+ * NOTES: fkb_init(fkb_p) will initialize fkb_p->blog_p to BLOG_NULL.
+ *
+ *------------------------------------------------------------------------------
+ */
+BlogAction_t blog_sinit(struct sk_buff * skb_p, struct net_device * dev_p,
+                        uint32_t encap, uint32_t channel, uint32_t phyHdr)
+{ return PKT_NORM; }
+
+BlogAction_t blog_finit(struct fkbuff * fkb_p, struct net_device * dev_p,
+                        uint32_t encap, uint32_t channel, uint32_t phyHdr )
+{
+    BlogKey_t blogKey;
+    BlogAction_t action = PKT_NORM;
+
+    blogKey.match = 0U;     /* also clears hash, protocol = 0 */
+
+    if ( unlikely(blog_rx_hook_g == (BlogHook_t)NULL) )
+        goto bypass;
+
+    blogKey.l1_tuple.channel = (uint8_t)channel;
+    blogKey.l1_tuple.phy     = phyHdr;
+
+    blog_assertr( ((phyHdr == BLOG_ENETPHY) || (phyHdr < 16)), PKT_NORM);
+    blog_print( "fkb<0x%08x> pData<0x%08x> length<%d> dev<0x%08x>"
+                " chnl<%u> %s PhyHdrLen<%u> key<0x%08x>",
+                (int)fkb_p, (int)fkb_p->data, fkb_p->len, (int)dev_p, channel, 
+                (phyHdr == BLOG_ENETPHY) ? "EPHY" : "XPHY",
+                (phyHdr == BLOG_ENETPHY) ?  0     : rfc2684HdrLength[phyHdr],
+                blogKey.match );
+
+    action = blog_rx_hook_g( fkb_p, dev_p, encap, blogKey.match );
+
+bypass:
+    return action;
+}
+#endif /* 6358 */
 
+#ifdef CONFIG_BCM96358
 /*
  *------------------------------------------------------------------------------
  * Function     : blog_emit
@@ -877,6 +1199,76 @@ BlogAction_t blog_emit( struct sk_buff *
 pkt_norm:
     return action;
 }
+#else /* 6362 */
+/*
+ *------------------------------------------------------------------------------
+ * Function     : blog_emit
+ * Description  : This function may be inserted in a physical network device's
+ *                hard_start_xmit function just before the packet data is
+ *                extracted from the sk_buff and enqueued for DMA transfer.
+ *
+ *                This function invokes the transmit blog hook.
+ * Parameters   :
+ *  nbuff_p     : Pointer to a NBuff
+ *  dev_p       : Pointer to the net_device on which the packet is transmited.
+ *  encap       : First encapsulation type
+ *  channel     : Channel/Port number on which the packet is transmited.
+ *  phyHdr      : e.g. XTM device RFC2684 header type
+ *
+ * Returns      :
+ *  PKT_DONE    : The skb_p is consumed and device should not process skb_p.
+ *  PKT_NORM    : Device may use skb_p and proceed with hard xmit 
+ *                Blog object is disassociated and freed.
+ *------------------------------------------------------------------------------
+ */
+BlogAction_t blog_emit( void * nbuff_p, struct net_device * dev_p,
+                        uint32_t encap, uint32_t channel, uint32_t phyHdr )
+{
+    BlogKey_t blogKey;
+    struct sk_buff * skb_p;
+    Blog_t * blog_p;
+    BlogAction_t action = PKT_NORM;
+
+    blog_assertr( (nbuff_p != (void *)NULL), PKT_NORM );
+
+    if ( !IS_SKBUFF_PTR(nbuff_p) )
+        goto bypass;
+    skb_p = PNBUFF_2_SKBUFF(nbuff_p);   /* same as nbuff_p */
+
+    blog_p = skb_p->blog_p;
+    if ( blog_p == BLOG_NULL )
+        goto bypass;
+
+    blogKey.match = 0U;
+
+    if ( likely(blog_tx_hook_g != (BlogHook_t)NULL) )
+    {
+        blog_p->tx.dev_p = dev_p;                   /* Log device info */
+
+        blogKey.l1_tuple.channel = (uint8_t)channel;
+        blogKey.l1_tuple.phy     = phyHdr;
+
+        blog_p->priority = skb_p->priority;         /* Log skb info */
+        blog_p->mark = skb_p->mark;
+
+        blog_assertr( ((phyHdr == BLOG_ENETPHY) || (phyHdr < 16)), PKT_NORM);
+        blog_print( "skb<0x%08x> blog<0x%08x> pData<0x%08x> length<%d>"
+                    " dev<0x%08x> chnl<%u> %s PhyHdrLen<%u> key<0x%08x>",
+            (int)skb_p, (int)blog_p, (int)skb_p->data, skb_p->len,
+            (int)dev_p,  channel,
+            (phyHdr == BLOG_ENETPHY) ? "EPHY" : "XPHY",
+            (phyHdr == BLOG_ENETPHY) ?  0     : rfc2684HdrLength[phyHdr],
+            blogKey.match );
+
+        action = blog_tx_hook_g( skb_p, skb_p->dev, encap, blogKey.match );
+    }
+
+    blog_free( skb_p );                             /* Dis-associate w/ skb */
+
+bypass:
+    return action;
+}
+#endif /* 6358 */
 
 /*
  *------------------------------------------------------------------------------
@@ -907,7 +1299,11 @@ void blog( struct sk_buff * skb_p, BlogD
 
     bHdr_p = &blog_p->rx + dir;
 
+#ifdef CONFIG_BCM96362
+    if ( encap == L3_IPv4 )    /* Log the IP Tuple */
+#else
     if ( encap == 10 )    /* Log the IP Tuple */
+#endif /* 6362 */
     {
         BlogTuple_t * bTuple_p = &bHdr_p->tuple;
         struct iphdr * ip_p    = (struct iphdr *)data_p;
@@ -941,8 +1337,19 @@ void blog( struct sk_buff * skb_p, BlogD
         bTuple_p->check = ip_p->check;
         bTuple_p->saddr = _read32_align16( (uint16_t *)&ip_p->saddr );
         bTuple_p->daddr = _read32_align16( (uint16_t *)&ip_p->daddr );
+#ifdef CONFIG_BCM96358
         blog_p->protocol = ip_p->protocol;
     }
+#else /* 6362 */
+        blog_p->key.protocol = ip_p->protocol;
+    }
+#ifdef CONFIG_BLOG_IPV6
+    else if ( encap == L3_IPv6 )    /* Log the IPv6 Tuple */
+    {
+        printk("FIXME blog encap L3_IPv6 \n");
+    }
+#endif
+#endif /* 6358 */
     else    /* L2 encapsulation */
     {
         register short int * d;
@@ -993,8 +1400,12 @@ skip:   /* Discontinue further logging b
  * CAUTION      : nf_conn is not held !!!
  *------------------------------------------------------------------------------
  */
+#ifdef CONFIG_BCM96362
+void blog_nfct_dump( struct sk_buff * skb_p, struct nf_conn * ct, uint32_t dir )
+#else
 void blog_nfct_dump( struct sk_buff * skb_p, struct nf_conn * ct,
                      uint16_t events, uint32_t dir )
+#endif
 {
     struct nf_conn_help *help_p;
     struct nf_conn_nat  *nat_p;
@@ -1034,13 +1445,14 @@ void blog_nfct_dump( struct sk_buff * sk
         if ( ct->status & (1 << bitix) )
             printk( "%s ", strIpctStatus[bitix] );
     printk( "]\n" );
+#ifdef CONFIG_BCM96358
 
     printk( "\t\tEVENT[ " );
     for ( bitix = 0; bitix <= IPCT_BLOG_BIT; bitix++ )
         if ( events & ( 1 << bitix) )
             printk( "%s ", strIpctEvents[bitix] );
     printk( "]\n" );
-
+#endif
 }
 
 /*
@@ -1056,7 +1468,7 @@ void blog_nfct_dump( struct sk_buff * sk
 static void blog_netdev_dump( struct net_device * dev_p )
 {
     int i;
-    printk( "\tDEVICE: %s dev_p<0x%08x>: poll[<%08x>] hard_start_xmit[<%08x>]\n"
+    printk( "\tDEVICE: %s dev<0x%08x>: poll[<%08x>] hard_start_xmit[<%08x>]\n"
             "\t  hard_header[<%08x>] hard_header_cache[<%08x>]\n"
             "\t  dev_addr[ ", dev_p->name,
             (int)dev_p, (int)dev_p->poll, (int)dev_p->hard_start_xmit,
@@ -1075,13 +1487,40 @@ static void blog_netdev_dump( struct net
  */
 static void blog_tuple_dump( BlogTuple_t * bTuple_p )
 {
+#ifdef CONFIG_BCM96362
+    printk( "\tIPv4:\n"
+            "\t\tSrc" _IPPFMT_ " Dst" _IPPFMT_ "\n"
+#else
     printk( "\tTUPLE: Src<%u.%u.%u.%u:%u> Dst<%u.%u.%u.%u:%u>\n"
+#endif
             "\t\tttl<%3u> tos<%3u> check<0x%04x>\n",
             _IP_(bTuple_p->saddr), bTuple_p->port.source,
             _IP_(bTuple_p->daddr), bTuple_p->port.dest,
             bTuple_p->ttl, bTuple_p->tos, bTuple_p->check );
 }
- 
+
+#ifdef CONFIG_BCM96362
+#if defined(CONFIG_BLOG_IPV6)
+/*
+ *------------------------------------------------------------------------------
+ * Function     : blog_tupleV6_dump
+ * Description  : Dump the contents of a BlogTupleV6_t object.
+ *  bTupleV6_p    : Pointer to the BlogTupleV6_t object
+ *------------------------------------------------------------------------------
+ */
+static void blog_tupleV6_dump( BlogTupleV6_t * bTupleV6_p )
+{
+    printk( "\tIPv6:\n"
+            "\t\tSrc" _IP6PFMT_ "\n"
+            "\t\tDst" _IP6PFMT_ "\n"
+            "\t\thop_limit<%3u> priority<%3u> exthdr_map<0x%04x>\n",
+            _IP6_(bTupleV6_p->saddr), bTupleV6_p->port.source,
+            _IP6_(bTupleV6_p->daddr), bTupleV6_p->port.dest,
+            bTupleV6_p->hop_limit, bTupleV6_p->priority,
+            bTupleV6_p->exthdr_map );
+}
+#endif
+#endif /* 6362 */
 /*
  *------------------------------------------------------------------------------
  * Function     : blog_l2_dump
@@ -1107,10 +1546,15 @@ void blog_l2_dump( BlogHeader_t * bHdr_p
             case VLAN_8021Q : length = sizeof(struct vlan_hdr); break;
             case ETH_802x   : length = sizeof(struct ethhdr);   break;
             case BCM_SWC    : length = sizeof(struct bcmhdr);   break;
-
+#ifdef CONFIG_BCM96362
+            case L3_IPv4    :
+            case L3_IPv6    :
+            case BCM_XPHY   :
+#else
             case WLAN_HDR   :
             case USB_CDC11  :
             case BCM_XTM    :
+#endif /* 6362 */
             default         : printk( "Unsupported type %d\n", type );
                               return;
         }
@@ -1135,6 +1579,7 @@ void blog_l2_dump( BlogHeader_t * bHdr_p
  *  blog_p      : Pointer to the Blog_t object
  *------------------------------------------------------------------------------
  */
+#ifdef CONFIG_BCM96358
 void blog_dump( Blog_t * blog_p )
 {
     if ( blog_p == BLOG_NULL )
@@ -1172,6 +1617,57 @@ void blog_dump( Blog_t * blog_p )
 #endif
 
 }
+#else /* 6362 */
+void blog_dump( Blog_t * blog_p )
+{
+    if ( blog_p == BLOG_NULL )
+        return;
+
+    printk( "BLOG <0x%08x> owner<0x%08x> ct<0x%08x>\n"
+            "\t\tL1 channel<%u> phy<%u> phyLen<%u> <%s>\n"
+            "\t\tfdb_src<0x%08x> fdb_dst<0x%08x>\n"
+            "\t\thash<%u> prot<%u> prio<0x%08x> mark<0x%08x>\n",
+            (int)blog_p, (int)blog_p->skb_p, (int)blog_p->rx.ct_p,
+            blog_p->key.l1_tuple.channel, blog_p->key.l1_tuple.phy,
+            (blog_p->key.l1_tuple.phy == (uint8_t)BCM_EPHY)
+               ?  0 : rfc2684HdrLength[blog_p->key.l1_tuple.phy],
+            (blog_p->key.l1_tuple.phy == (uint8_t)BCM_EPHY) ? "EPHY" : "XPHY",
+            (int)blog_p->fdb_src, (int)blog_p->fdb_dst,
+            blog_p->key.hash, blog_p->key.protocol,
+            blog_p->priority, blog_p->mark );
+
+    if ( blog_p->rx.ct_p )
+        blog_nfct_dump( blog_p->skb_p, blog_p->rx.ct_p, blog_p->rx.nf_dir );
+
+    printk( "  RX count<%u> channel<%02u> phyHdr<%2u> bmap<%x>\n",
+            blog_p->rx.info.count, blog_p->rx.info.channel,
+            blog_p->rx.info.phyHdr, blog_p->rx.info.hdrs );
+    if ( blog_p->rx.info.bmap.L3_IPv4 )
+        blog_tuple_dump( &blog_p->rx.tuple );
+    blog_l2_dump( &blog_p->rx );
+
+    printk( "  TX count<%u> channel<%02u> phyHdr<%2u> bmap<%x>\n",
+            blog_p->tx.info.count, blog_p->tx.info.channel,
+            blog_p->tx.info.phyHdr, blog_p->tx.info.hdrs );
+    if ( blog_p->tx.dev_p )
+        blog_netdev_dump( blog_p->tx.dev_p );
+    if ( blog_p->rx.info.bmap.L3_IPv4 )
+        blog_tuple_dump( &blog_p->tx.tuple );
+    blog_l2_dump( &blog_p->tx );
+
+#if defined(CONFIG_BLOG_IPV6)
+    if ( blog_p->rx.info.bmap.L3_IPv6 )
+        blog_tupleV6_dump( &blog_p->tupleV6 );
+#endif
+
+#if defined(CC_CONFIG_BLOG_DEBUG)
+    printk( "\t\textends<%d> free<%d> used<%d> HWM<%d> fails<%d>\n",
+            blog_extends, blog_cnt_free, blog_cnt_used, blog_cnt_hwm,
+            blog_cnt_fails );
+#endif
+
+}
+#endif /* 6358 */
 
 /*
  *------------------------------------------------------------------------------
@@ -1202,9 +1698,17 @@ static int __init __init_blog( void )
 {
     nfskb_p = alloc_skb( 0, GFP_ATOMIC );
     blog_refresh_fn = (blog_refresh_t)NULL;
+#ifdef CONFIG_BCM96358
     blog_construct( BLOG_EXTEND_SIZE * BLOG_EXTEND_MAX );
+#else
+    blog_construct( BLOG_EXTEND_SIZE_ENGG * BLOG_EXTEND_MAX_ENGG );
+#endif /* 6358 */
     blog_print( "%d Blogs allocated of size %d", 
+#ifdef CONFIG_BCM96358
                 BLOG_EXTEND_SIZE * BLOG_EXTEND_MAX, sizeof(Blog_t) );
+#else
+                BLOG_EXTEND_SIZE_ENGG * BLOG_EXTEND_MAX_ENGG, sizeof(Blog_t) );
+#endif /* 6358 */
     printk( CLRb "BLOG %s Initialized" CLRN, BLOG_VERSION );
     return 0;
 }
@@ -1226,21 +1730,76 @@ EXPORT_SYMBOL(blog_skb);
 EXPORT_SYMBOL(blog_free);
 EXPORT_SYMBOL(blog_dump);
 EXPORT_SYMBOL(blog_skip);
+#ifdef CONFIG_BCM96358
 EXPORT_SYMBOL(blog_null);
+EXPORT_SYMBOL(blog_ctev);
+EXPORT_SYMBOL(blog_init);
+EXPORT_SYMBOL(blog_bind);
+#endif
 EXPORT_SYMBOL(blog_link);
 EXPORT_SYMBOL(blog_xfer);
 EXPORT_SYMBOL(blog_clone);
 
 EXPORT_SYMBOL(blog_br_fdb);
 EXPORT_SYMBOL(blog_nfct);
-EXPORT_SYMBOL(blog_ctev);
+
+
+
 EXPORT_SYMBOL(blog_flow);
 EXPORT_SYMBOL(blog_stop);
+#ifdef CONFIG_NETFILTER
 EXPORT_SYMBOL(blog_time);
+#endif
 
-EXPORT_SYMBOL(blog_init);
 EXPORT_SYMBOL(blog_emit);
 
 EXPORT_SYMBOL(blog);
 
-EXPORT_SYMBOL(blog_bind);
+#else /* !CONFIG_BLOG */
+
+int blog_mcast_g = 0; /* = CC_SUPPORT_BLOG_MCAST; */
+void blog_mcast(int enable) { blog_mcast_g = 0; /* = enable; */ }
+
+/* Stub functions for Blog APIs that may be used by modules */
+void blog_put( Blog_t * blog_p ) { return; }
+Blog_t * blog_skb( struct sk_buff * skb_p ) { return BLOG_NULL; }
+Blog_t * blog_fkb( struct fkbuff * fkb_p ) { return BLOG_NULL; }
+Blog_t * blog_snull( struct sk_buff * skb_p ) { return BLOG_NULL; }
+Blog_t * blog_fnull( struct fkbuff * fkb_p ) { return BLOG_NULL; }
+void blog_free(struct sk_buff * skb_p) { return; }
+void blog_dump(Blog_t * blog_p) { return; }
+void blog_skip(struct sk_buff * skb_p) { return; }
+void blog_link(struct sk_buff * skb_p, Blog_t * blog_p) { return; }
+void blog_xfer(struct sk_buff * skb_p, const struct sk_buff * prev_p){ return; }
+void blog_move(struct sk_buff * skb_p, struct fkbuff * fkb_p){ return; }
+void blog_clone(struct sk_buff * skb_p, const struct blog_t * prev_p){ return; }
+
+BlogAction_t blog_sinit(struct sk_buff * skb_p, struct net_device * dev_p,
+                        uint32_t encap, uint32_t channel, uint32_t phyHdr)
+{ return PKT_NORM; }
+
+struct fkbuff;
+BlogAction_t blog_finit(struct fkbuff * fkb_p, struct net_device * dev_p,
+                       uint32_t encap, uint32_t channel, uint32_t phyHdr)
+{ return PKT_NORM; }
+
+BlogAction_t blog_emit(void * nbuff_p, struct net_device * dev_p,
+                       uint32_t encap, uint32_t channel, uint32_t phyHdr)
+{ return PKT_NORM; }
+
+void blog(struct sk_buff * skb_p, BlogDir_t dir, BlogEncap_t encap,
+          size_t len, void * data_p)
+{ return; }
+
+#endif  /* else !defined(CONFIG_BLOG) */
+#ifdef CONFIG_BCM96362
+
+EXPORT_SYMBOL(blog_mcast_g);
+EXPORT_SYMBOL(blog_mcast);
+
+EXPORT_SYMBOL(blog_fkb);
+EXPORT_SYMBOL(blog_snull);
+EXPORT_SYMBOL(blog_fnull);
+EXPORT_SYMBOL(blog_move);
+EXPORT_SYMBOL(blog_finit);
+#endif
