diff -pruN inadyn-v1.96.2.old/src/dyndns.c inadyn-v1.96.2/src/dyndns.c
--- inadyn-v1.96.2.old/src/dyndns.c	2008-10-23 14:10:37.000000000 +0200
+++ inadyn-v1.96.2/src/dyndns.c	2008-10-23 16:49:30.000000000 +0200
@@ -546,11 +546,14 @@ RC_TYPE get_default_config_data(DYN_DNS_
             rc = RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT;
             break;
         }
-						
+					
 		/*forced update period*/
 		p_self->forced_update_period_sec = DYNDNS_MY_FORCED_UPDATE_PERIOD_S;
 		/*update period*/
-		p_self->sleep_sec = DYNDNS_DEFAULT_SLEEP;					
+		p_self->sleep_sec = DYNDNS_DEFAULT_SLEEP;
+
+		/*pidfile*/
+		snprintf(p_self->pidfile, sizeof(p_self->pidfile), DYNDNS_DEFAULT_PIDFILE);
 	}
 	while(0);
 	
@@ -983,14 +983,27 @@ int dyn_dns_main(DYN_DNS_CLIENT *p_dyndn
 
     nbd_status_set("ddns_status", "starting");
 
+    /* write pid file */
+    if((fp=fopen(p_dyndns->pidfile, "w")))
+    {
+	    fprintf(fp, "%u", getpid());
+	    fclose(fp);
+	    fp=NULL;
+    }
+    else
+    {
+	    nbd_status_set("ddns_status", "error_internal");
+	    return rc;
+    }
+
     dyn_dns_print_hello(NULL);
     do {
 	    fp = NULL;
 	    
 	    /* get last modification of cache and conf file, if m_time conf file is > to m_time cache file, no use cache ! */
-	    if(stat("/var/ddns/ddnsd.conf", &sb) != 0)
+	    if(stat(p_dyndns->cfgfile, &sb) != 0)
 	    {
-		    DBG_PRINTF((LOG_INFO, MODULE_TAG "stat on '/var/ddns/ddnsd.conf' failed !\n"));
+		    DBG_PRINTF((LOG_INFO, MODULE_TAG "stat on '%s' failed !\n", p_dyndns->cfgfile));
 		    break;
 	    }
 	    t_mod_conf = sb.st_mtime;
diff -pruN inadyn-v1.96.2.old/src/dyndns.h inadyn-v1.96.2/src/dyndns.h
--- inadyn-v1.96.2.old/src/dyndns.h	2008-10-23 14:10:37.000000000 +0200
+++ inadyn-v1.96.2/src/dyndns.h	2008-10-23 16:17:54.000000000 +0200
@@ -126,6 +126,7 @@ typedef enum
 
 /* SOME DEFAULT CONFIGURATIONS */
 #define DYNDNS_DEFAULT_SLEEP	(120) /*s*/
+#define DYNDNS_DEFAULT_PIDFILE  "/var/run/inadyn.pid"
 #define DYNDNS_MIN_SLEEP	(30) /*s*/
 #define DYNDNS_MAX_SLEEP	(10 * 24 * 3600) /*10 days in s*/
 #define DYNDNS_MY_FORCED_UPDATE_PERIOD_S   (30 * 24 * 3600) /* 30 days in sec*/
@@ -243,7 +244,9 @@ typedef struct DYN_DNS_CLIENT
 	int forced_update_times; /* the same forced update period counted in sleep periods*/
 	int cmd_check_period; /*time to wait for a command*/
 	int total_iterations;
-	char * interface;
+	char interface[16];
+	char cfgfile[128];
+	char pidfile[128];
 	BOOL initialized;
 	BOOL run_in_background;
 	BOOL debug_to_syslog;
diff -pruN inadyn-v1.96.2.old/src/get_cmd.c inadyn-v1.96.2/src/get_cmd.c
--- inadyn-v1.96.2.old/src/get_cmd.c	2008-10-23 14:10:37.000000000 +0200
+++ inadyn-v1.96.2/src/get_cmd.c	2008-10-23 15:34:40.000000000 +0200
@@ -1,27 +1,27 @@
 /*
-Copyright (C) 2003-2004 Narcis Ilisei
+  Copyright (C) 2003-2004 Narcis Ilisei
 
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License
+  as published by the Free Software Foundation; either version 2
+  of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
 /* 
-	Inplementation functions for CMD options parsing system
-	Author: Narcis Ilisei
-	Date: May 2003
-	History:
-		- may 15 2003 : first version.
-			Basic, table driven option line parsing.
+   Inplementation functions for CMD options parsing system
+   Author: Narcis Ilisei
+   Date: May 2003
+   History:
+   - may 15 2003 : first version.
+   Basic, table driven option line parsing.
 */ 
 
 #define MODULE_TAG "INADYN:CMD_LINE_OPT: "
@@ -48,117 +48,117 @@ static CMD_DESCRIPTION_TYPE * opt_search
 }
 
 /**
-	 Init the CMD_DATA
+   Init the CMD_DATA
 */
 RC_TYPE cmd_init(CMD_DATA *p_cmd)
 {
-    if (!p_cmd)
-    {
-        return RC_INVALID_POINTER;
-    }	
-    memset(p_cmd, 0, sizeof(*p_cmd));
-    return RC_OK;
+	if (!p_cmd)
+	{
+		return RC_INVALID_POINTER;
+	}	
+	memset(p_cmd, 0, sizeof(*p_cmd));
+	return RC_OK;
 }
 
 RC_TYPE cmd_destruct(CMD_DATA *p_cmd)
 {
-    if (!p_cmd)
-    {
-        return RC_INVALID_POINTER;
-    }	
-    if (p_cmd->argv)
-    {
-    	int i;
-    	for (i = 0; i < p_cmd->argc; ++i)
-    	{
-    		if (p_cmd->argv[i])
-    		{
-    			free(p_cmd->argv[i]);
-    		}
-    	}
-    	free(p_cmd->argv);
-    }
-    return RC_OK;
+	if (!p_cmd)
+	{
+		return RC_INVALID_POINTER;
+	}	
+	if (p_cmd->argv)
+	{
+		int i;
+		for (i = 0; i < p_cmd->argc; ++i)
+		{
+			if (p_cmd->argv[i])
+			{
+				free(p_cmd->argv[i]);
+			}
+		}
+		free(p_cmd->argv);
+	}
+	return RC_OK;
 }
 
 /** Adds a new option (string) to the command line 
-*/
+ */
 RC_TYPE cmd_add_val(CMD_DATA *p_cmd, char *p_val)
 {
 	RC_TYPE rc = RC_OK;
-    if (!p_cmd || !p_val)
-    {
-        return RC_INVALID_POINTER;
-    }
-    do
-    {
-    	{
-        	char **pp = (char **) realloc(p_cmd->argv, (p_cmd->argc + 1) * sizeof(char*));  
-        	if (!pp)
-        	{
-        		rc = RC_OUT_OF_MEMORY;
-        		break;
-       		}
-       		p_cmd->argv = pp;
-        }
-        {
-        	{
-        		char *p = (char*) malloc(strlen(p_val) + 1);
-        		if (!p)
-        		{
-        		 	rc = RC_OUT_OF_MEMORY;
-        		 	break;
-            	} 
-           		strcpy(p, p_val);
-        	    p_cmd->argv[p_cmd->argc] = p;
-        	    p_cmd->argc ++;      		
-        	}
-        }
-    }
-    while(0);
-    return rc;		
+	if (!p_cmd || !p_val)
+	{
+		return RC_INVALID_POINTER;
+	}
+	do
+	{
+		{
+			char **pp = (char **) realloc(p_cmd->argv, (p_cmd->argc + 1) * sizeof(char*));  
+			if (!pp)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
+			p_cmd->argv = pp;
+		}
+		{
+			{
+				char *p = (char*) malloc(strlen(p_val) + 1);
+				if (!p)
+				{
+					rc = RC_OUT_OF_MEMORY;
+					break;
+				} 
+				strcpy(p, p_val);
+				p_cmd->argv[p_cmd->argc] = p;
+				p_cmd->argc ++;      		
+			}
+		}
+	}
+	while(0);
+	return rc;		
 }
 /** Creates a struct of argvals from the given command line.
     Action:
-        copy the argv from the command line to the given CMD_DATA struct
-        set the data val of the list element to the current argv
+    copy the argv from the command line to the given CMD_DATA struct
+    set the data val of the list element to the current argv
 */
 RC_TYPE cmd_add_vals_from_argv(CMD_DATA *p_cmd, char **argv, int argc)
 {
 	RC_TYPE rc = RC_OK;
-    if (!p_cmd || !argv || !argc)
-    {
-        return RC_INVALID_POINTER;
-    }
-    do
-    {
-    	int i;
-    	for (i = 0; i < argc; ++i)
-    	{
-    		rc = cmd_add_val(p_cmd, argv[i]);
-    	}
-    }
-    while(0);
-    return rc;
+	if (!p_cmd || !argv || !argc)
+	{
+		return RC_INVALID_POINTER;
+	}
+	do
+	{
+		int i;
+		for (i = 0; i < argc; ++i)
+		{
+			rc = cmd_add_val(p_cmd, argv[i]);
+		}
+	}
+	while(0);
+	return rc;
 }
 
 
 /*
-	Parses the incoming argv list.
-	Arguments:
-		argv, argc,
-		cmd description 
-
-	Action:
-		performs a match for every p_option string in the CMD description.
-		checks the number of arguments left
-		calls the user handler with the pointer to the correct arguments
-
-	Implementation:
-		- for each option in the table
-			- find it in the argv list
-			- check the required number of arguments
-			- call the handler
+  Parses the incoming argv list.
+  Arguments:
+  argv, argc,
+  cmd description 
+
+  Action:
+  performs a match for every p_option string in the CMD description.
+  checks the number of arguments left
+  calls the user handler with the pointer to the correct arguments
+
+  Implementation:
+  - for each option in the table
+  - find it in the argv list
+  - check the required number of arguments
+  - call the handler
 */
 RC_TYPE get_cmd_parse_data(char **argv, int argc, CMD_DESCRIPTION_TYPE *p_cmd_descr)
 {
@@ -190,8 +190,8 @@ RC_TYPE get_cmd_parse_data(char **argv, 
 			if (p_curr_opt == NULL)
 			{
 				rc = RC_CMD_PARSER_INVALID_OPTION;
-	            DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Invalid option name at position %d ('%s')\n", 
-	                        curr_arg_nr + 1, cmd.argv[curr_arg_nr]));
+				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Invalid option name at position %d ('%s')\n", 
+					    curr_arg_nr + 1, cmd.argv[curr_arg_nr]));
 				break;
 			}
 	
@@ -201,16 +201,16 @@ RC_TYPE get_cmd_parse_data(char **argv, 
 			if (curr_arg_nr + p_curr_opt->arg_nr > cmd.argc)
 			{
 				rc = RC_CMD_PARSER_INVALID_OPTION_ARGUMENT;
-	            DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Missing option value at position %d ('%s')\n", 
-	                        curr_arg_nr + 1, p_curr_opt->p_option));
-	            break;
+				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Missing option value at position %d ('%s')\n", 
+					    curr_arg_nr + 1, p_curr_opt->p_option));
+				break;
 			}
 					
 			rc = p_curr_opt->p_handler.p_func(&cmd, curr_arg_nr, p_curr_opt->p_handler.p_context);
 			if (rc != RC_OK)
 			{
-	            DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error parsing option %d ('%s')\n", 
-	                        curr_arg_nr, cmd.argv[curr_arg_nr-1]));
+				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error parsing option %d ('%s')\n", 
+					    curr_arg_nr, cmd.argv[curr_arg_nr-1]));
 				break;
 			}
 			
diff -pruN inadyn-v1.96.2.old/src/inadyn_cmd.c inadyn-v1.96.2/src/inadyn_cmd.c
--- inadyn-v1.96.2.old/src/inadyn_cmd.c	2008-10-23 14:10:37.000000000 +0200
+++ inadyn-v1.96.2/src/inadyn_cmd.c	2008-10-23 16:28:40.000000000 +0200
@@ -1,32 +1,32 @@
 /*
-Copyright (C) 2003-2004 Narcis Ilisei
+  Copyright (C) 2003-2004 Narcis Ilisei
 
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License
+  as published by the Free Software Foundation; either version 2
+  of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
 
 /*
-	Dyn Dns update main implementation file 
-	Author: narcis Ilisei
-	Date: May 2003
-
-	History:
-		- first implemetnation
-		- 18 May 2003 : cmd line option reading added - 
-		- many options added
-		- january 2005 - new format for the config file =Thanks to Jerome Benoit. 
-        - january 30 2005 - new parser for config file -
+  Dyn Dns update main implementation file 
+  Author: narcis Ilisei
+  Date: May 2003
+
+  History:
+  - first implemetnation
+  - 18 May 2003 : cmd line option reading added - 
+  - many options added
+  - january 2005 - new format for the config file =Thanks to Jerome Benoit. 
+  - january 30 2005 - new parser for config file -
 */
 #define MODULE_TAG "CMD_OPTS: "
 
@@ -62,6 +62,7 @@ static RC_TYPE set_iterations_handler(CM
 static RC_TYPE set_syslog_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_change_persona_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_bind_interface(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE set_pidfile(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE print_version_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 
 static CMD_DESCRIPTION_TYPE cmd_options_table[] = 
@@ -79,37 +80,37 @@ static CMD_DESCRIPTION_TYPE cmd_options_
 	{"-a",			1,	{get_alias_handler, NULL},	"alias host name. this option can appear multiple times." },
 
 	{DYNDNS_INPUT_FILE_OPT_STRING, 1, {get_options_from_file_handler, NULL}, "the file containing [further] inadyn options."
-			"The default config file, '" DYNDNS_DEFAULT_CONFIG_FILE "' is used if inadyn is called without any cmd line options." },
+	 "The default config file, '" DYNDNS_DEFAULT_CONFIG_FILE "' is used if inadyn is called without any cmd line options." },
 	
 	{"--ip_server_name",	2,	{get_ip_server_name_handler, NULL},
-        "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL. \n"
-		"\t\tThe first IP in found in http response is considered 'my IP'. \n"
-		"\t\tDefault value: 'checkip.dyndns.org /"},
+	 "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL. \n"
+	 "\t\tThe first IP in found in http response is considered 'my IP'. \n"
+	 "\t\tDefault value: 'checkip.dyndns.org /"},
 
 	{"--dyndns_server_name", 1,	{get_dns_server_name_handler, NULL},	
-            "[<NAME>[:port]] \n"
-            "\t\tThe server that receives the update DNS request.  \n"
-            "\t\tAllows the use of unknown DNS services that accept HTTP updates.\n"  
-            "\t\tIf no proxy is wanted, then it is enough to set the dyndns system. The default servers will be taken."},
+	 "[<NAME>[:port]] \n"
+	 "\t\tThe server that receives the update DNS request.  \n"
+	 "\t\tAllows the use of unknown DNS services that accept HTTP updates.\n"  
+	 "\t\tIf no proxy is wanted, then it is enough to set the dyndns system. The default servers will be taken."},
 
 	{"--dyndns_server_url", 1, {get_dns_server_url_handler, NULL},	
-            "<name>\n"
-			"\tfull URL relative to DynDNS server root.\n"
-			"\tEx: /some_script.php?hostname=\n"},	
+	 "<name>\n"
+	 "\tfull URL relative to DynDNS server root.\n"
+	 "\tEx: /some_script.php?hostname=\n"},	
 
 	{"--dyndns_system",	1,	{get_dyndns_system_handler, NULL},	
-            "[NAME] - optional DYNDNS service type. SHOULD be one of the following: \n"
-            "\t\t-For dyndns.org DNS system: dyndns@dyndns.org OR statdns@dyndns.org OR customdns@dyndns.org.\n"
-            "\t\t-For freedns.afraid.org DNS system: default@freedns.afraid.org\n"
-            "\t\t-For www.zoneedit.com DNS system: default@zoneedit.com\n"
-            "\t\t-For www.no-ip.com DNS system: default@no-ip.com\n"
-			"\t\t-For generic DNS system: custom@http_svr_basic_auth\n"
-            "\t\tDEFAULT value is intended for default service at dyndns.org (most users): dyndns@dyndns.org"},
+	 "[NAME] - optional DYNDNS service type. SHOULD be one of the following: \n"
+	 "\t\t-For dyndns.org DNS system: dyndns@dyndns.org OR statdns@dyndns.org OR customdns@dyndns.org.\n"
+	 "\t\t-For freedns.afraid.org DNS system: default@freedns.afraid.org\n"
+	 "\t\t-For www.zoneedit.com DNS system: default@zoneedit.com\n"
+	 "\t\t-For www.no-ip.com DNS system: default@no-ip.com\n"
+	 "\t\t-For generic DNS system: custom@http_svr_basic_auth\n"
+	 "\t\tDEFAULT value is intended for default service at dyndns.org (most users): dyndns@dyndns.org"},
 
-    {"--proxy_server", 1, {get_proxy_server_handler, NULL},
-            "[NAME[:port]]  - the http proxy server name and port. Default is none."},
+	{"--proxy_server", 1, {get_proxy_server_handler, NULL},
+	 "[NAME[:port]]  - the http proxy server name and port. Default is none."},
 	{"--update_period",	1,	{get_update_period_handler, NULL},	
-            "how often the IP is checked. The period is in [ms]. Default is about 1 min. Max is 10 days"},
+	 "how often the IP is checked. The period is in [ms]. Default is about 1 min. Max is 10 days"},
 	{"--update_period_sec",	1,	{get_update_period_sec_handler, NULL},	"how often the IP is checked. The period is in [sec]. Default is about 1 min. Max is 10 days"},
 	{"--forced_update_period", 1,   {get_forced_update_period_handler, NULL},"how often the IP is updated even if it is not changed. [in sec]"},
 
@@ -122,6 +123,7 @@ static CMD_DESCRIPTION_TYPE cmd_options_
 	{"--syslog",	0,	{set_syslog_handler, NULL},	"force logging to syslog . (e.g. /var/log/messages). Works on **NIX systems only."},
 	{"--change_persona", 1, {set_change_persona_handler, NULL}, "after init switch to a new user/group. Parameters: <uid[:gid]> to change to. Works on **NIX systems only."},
 	{"--bind_interface", 1, {set_bind_interface, NULL}, "set interface to bind. Parameters: <interface>. Works on **NIX systems only."},
+	{"--pidfile", 1, {set_pidfile, NULL}, "set pid file (by default /var/run/inadyn.pid)."},
 	{"--version", 0, {print_version_handler, NULL}, "print the version number\n"},
 	{NULL,		0,	{0, NULL},	NULL }
 };
@@ -130,18 +132,18 @@ static CMD_DESCRIPTION_TYPE cmd_options_
 void print_help_page(void)
 {
 	printf("\n\n\n"
-	"			INADYN Help\n\n"
-	"	INADYN is a dynamic DNS client. That is, it maintains the IP address\n"
-	"of a host name. It periodically checks whether the IP address of the current machine\n"
-	"(the external visible IP address of the machine that runs INADYN) has changed.\n"
-    "If yes it performs an update in the dynamic dns server.\n\n");
-    printf("Typical usage: \n"	
-    "\t-for dyndns.org system: \n"
-    "\t\tinadyn -u username -p password -a my.registrated.name \n"
-    "\t-for freedns.afraid.org:\n"
-    "\t\t inadyn --dyndns_system default@freedns.afraid.org -a my.registrated.name,hash -a anothername,hash2\n"
-    "\t\t\t 'hash' is extracted from the grab url batch file that is downloaded from freedns.afraid.org\n\n"
-	"Parameters:\n");
+	       "			INADYN Help\n\n"
+	       "	INADYN is a dynamic DNS client. That is, it maintains the IP address\n"
+	       "of a host name. It periodically checks whether the IP address of the current machine\n"
+	       "(the external visible IP address of the machine that runs INADYN) has changed.\n"
+	       "If yes it performs an update in the dynamic dns server.\n\n");
+	printf("Typical usage: \n"	
+	       "\t-for dyndns.org system: \n"
+	       "\t\tinadyn -u username -p password -a my.registrated.name \n"
+	       "\t-for freedns.afraid.org:\n"
+	       "\t\t inadyn --dyndns_system default@freedns.afraid.org -a my.registrated.name,hash -a anothername,hash2\n"
+	       "\t\t\t 'hash' is extracted from the grab url batch file that is downloaded from freedns.afraid.org\n\n"
+	       "Parameters:\n");
 
 	{
 		CMD_DESCRIPTION_TYPE *it = cmd_options_table;
@@ -268,11 +270,11 @@ static RC_TYPE get_password_handler(CMD_
 }
 
 /**
-    Parses alias,hash.
-    Example: blabla.domain.com,hashahashshahah
-    Action:
-	-search by ',' and replace the ',' with 0
-	-read hash and alias
+   Parses alias,hash.
+   Example: blabla.domain.com,hashahashshahah
+   Action:
+   -search by ',' and replace the ',' with 0
+   -read hash and alias
 */
 static RC_TYPE get_alias_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
@@ -293,12 +295,12 @@ static RC_TYPE get_alias_handler(CMD_DAT
         p_hash = strstr(p_cmd->argv[current_nr],",");
         if (p_hash)
 	{
-	    if (sizeof(*p_self->alias_info.hashes) < strlen(p_hash))
-	    {
-		return RC_DYNDNS_BUFFER_TOO_SMALL;
-	    }
-	    strcpy(p_self->alias_info.hashes[p_self->alias_info.count].str, p_hash);
-	    *p_hash = '\0';
+		if (sizeof(*p_self->alias_info.hashes) < strlen(p_hash))
+		{
+			return RC_DYNDNS_BUFFER_TOO_SMALL;
+		}
+		strcpy(p_self->alias_info.hashes[p_self->alias_info.count].str, p_hash);
+		*p_hash = '\0';
 	}
 
 
@@ -315,26 +317,26 @@ static RC_TYPE get_alias_handler(CMD_DAT
 
 static RC_TYPE get_name_and_port(char *p_src, char *p_dest_name, int *p_dest_port)
 {
-    const char *p_port = NULL;
-    p_port = strstr(p_src,":");
-    if (p_port)
-    {
-        int port_nr, len;
-        int port_ok = sscanf(p_port + 1, "%d",&port_nr);
-        if (port_ok != 1)
-        {
-            return RC_DYNDNS_INVALID_OPTION;
-        }
-        *p_dest_port = port_nr;
-        len = p_port - p_src;
-        memcpy(p_dest_name, p_src, len);
-        p_dest_name[len] = 0;
-    }
-    else
-    {
-        strcpy(p_dest_name, p_src);
-    }
-    return RC_OK;
+	const char *p_port = NULL;
+	p_port = strstr(p_src,":");
+	if (p_port)
+	{
+		int port_nr, len;
+		int port_ok = sscanf(p_port + 1, "%d",&port_nr);
+		if (port_ok != 1)
+		{
+			return RC_DYNDNS_INVALID_OPTION;
+		}
+		*p_dest_port = port_nr;
+		len = p_port - p_src;
+		memcpy(p_dest_name, p_src, len);
+		p_dest_name[len] = 0;
+	}
+	else
+	{
+		strcpy(p_dest_name, p_src);
+	}
+	return RC_OK;
 }
 
 /** Returns the svr name and port if the format is :
@@ -343,8 +345,8 @@ static RC_TYPE get_name_and_port(char *p
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
-    RC_TYPE rc;
-    int port = -1;
+	RC_TYPE rc;
+	int port = -1;
 
 	if (p_self == NULL)
 	{
@@ -357,12 +359,12 @@ static RC_TYPE get_ip_server_name_handle
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
 
-    p_self->info.ip_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.ip_server_name.name, &port);
-    if (rc == RC_OK && port != -1)
-    {
-        p_self->info.ip_server_name.port = port;
-    }        
+	p_self->info.ip_server_name.port = HTTP_DEFAULT_PORT;
+	rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.ip_server_name.name, &port);
+	if (rc == RC_OK && port != -1)
+	{
+		p_self->info.ip_server_name.port = port;
+	}        
 
 	if (sizeof(p_self->info.ip_server_url) < strlen(p_cmd->argv[current_nr + 1]) + 1)
 	{
@@ -376,8 +378,8 @@ static RC_TYPE get_ip_server_name_handle
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
-    RC_TYPE rc;
-    int port = -1;
+	RC_TYPE rc;
+	int port = -1;
 
 	if (p_self == NULL)
 	{
@@ -390,12 +392,12 @@ static RC_TYPE get_dns_server_name_handl
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
     
-    p_self->info.dyndns_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.dyndns_server_name.name, &port);
-    if (rc == RC_OK && port != -1)
-    {
-        p_self->info.dyndns_server_name.port = port;
-    }                                   
+	p_self->info.dyndns_server_name.port = HTTP_DEFAULT_PORT;
+	rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.dyndns_server_name.name, &port);
+	if (rc == RC_OK && port != -1)
+	{
+		p_self->info.dyndns_server_name.port = port;
+	}                                   
 	return rc;
 }
 
@@ -417,12 +419,12 @@ RC_TYPE get_dns_server_url_handler(CMD_D
 }
 
 /* returns the proxy server nme and port
-*/
+ */
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
-    RC_TYPE rc;
-    int port = -1;
+	RC_TYPE rc;
+	int port = -1;
 
 	if (p_self == NULL)
 	{
@@ -435,12 +437,12 @@ static RC_TYPE get_proxy_server_handler(
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
     
-    p_self->info.proxy_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.proxy_server_name.name, &port);
-    if (rc == RC_OK && port != -1)
-    {
-        p_self->info.proxy_server_name.port = port;
-    }                                   
+	p_self->info.proxy_server_name.port = HTTP_DEFAULT_PORT;
+	rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.proxy_server_name.name, &port);
+	if (rc == RC_OK && port != -1)
+	{
+		p_self->info.proxy_server_name.port = port;
+	}                                   
 	return rc;    
 }
 
@@ -533,7 +535,7 @@ static RC_TYPE set_change_persona_handle
 		if (p_gid)
 		{
 			if ((strlen(p_gid + 1) > 0) &&  /* if something is present after :*/
-				sscanf(p_gid + 1, "%d",&gid) != 1)
+			    sscanf(p_gid + 1, "%d",&gid) != 1)
 			{
 				return RC_DYNDNS_INVALID_OPTION;
 			}
@@ -557,13 +559,36 @@ static RC_TYPE set_bind_interface(CMD_DA
 	{
 		return RC_INVALID_POINTER;
 	}
+
+	if (sizeof(p_self->interface) < strlen(p_cmd->argv[current_nr]))
+	{
+		return  RC_DYNDNS_BUFFER_TOO_SMALL;
+	}
+
 	p_self->bind_interface = TRUE;
-	p_self->interface = malloc (sizeof(p_cmd->argv[current_nr]));
-    strncpy(p_self->interface, p_cmd->argv[current_nr], sizeof(p_cmd->argv[current_nr]));
+    	snprintf(p_self->interface, sizeof(p_self->interface), "%s", p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
 
+static RC_TYPE set_pidfile(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	if (sizeof(p_self->pidfile) < strlen(p_cmd->argv[current_nr]))
+	{
+		return  RC_DYNDNS_BUFFER_TOO_SMALL;
+	}
+	
+    	snprintf(p_self->pidfile, sizeof(p_self->pidfile), "%s", p_cmd->argv[current_nr]);
+	
+	return RC_OK;
+}
+
 RC_TYPE print_version_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -585,30 +610,30 @@ RC_TYPE print_version_handler(CMD_DATA *
 */
 static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
-    DYNDNS_SYSTEM *p_dns_system = NULL;
+	DYNDNS_SYSTEM *p_dns_system = NULL;
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
 	}
     
-    {
-        DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
-        for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it)
-        {
-            if (strcmp(it->system.p_key, p_cmd->argv[current_nr]) == 0)
-            {
-                p_dns_system = &it->system;
-            }
-        }    
-    }
-
-    if (p_dns_system == NULL)
-    {
-        return RC_DYNDNS_INVALID_OPTION;
-    }
+	{
+		DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
+		for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it)
+		{
+			if (strcmp(it->system.p_key, p_cmd->argv[current_nr]) == 0)
+			{
+				p_dns_system = &it->system;
+			}
+		}    
+	}
+
+	if (p_dns_system == NULL)
+	{
+		return RC_DYNDNS_INVALID_OPTION;
+	}
 
-    p_self->info.p_dns_system = p_dns_system;
+	p_self->info.p_dns_system = p_dns_system;
 	
 	return RC_OK;
 }
@@ -616,206 +641,206 @@ static RC_TYPE get_dyndns_system_handler
 
 static RC_TYPE push_in_buffer(char* p_src, int src_len, char *p_buffer, int* p_act_len, int max_len)
 {
-    if (*p_act_len + src_len > max_len)
-    {
-        return RC_FILE_IO_OUT_OF_BUFFER;
-    }
-    memcpy(p_buffer + *p_act_len,p_src, src_len);
-    *p_act_len += src_len;
-    return RC_OK;
+	if (*p_act_len + src_len > max_len)
+	{
+		return RC_FILE_IO_OUT_OF_BUFFER;
+	}
+	memcpy(p_buffer + *p_act_len,p_src, src_len);
+	*p_act_len += src_len;
+	return RC_OK;
 }
 
 typedef enum 
 {
-    NEW_LINE,
-    COMMENT,
-    DATA,
-    SPACE,
-    ESCAPE
+	NEW_LINE,
+	COMMENT,
+	DATA,
+	SPACE,
+	ESCAPE
 } PARSER_STATE;
 
 typedef struct 
 {
-    FILE *p_file;
-    PARSER_STATE state;
+	FILE *p_file;
+	PARSER_STATE state;
 } OPTION_FILE_PARSER;
 
 static RC_TYPE parser_init(OPTION_FILE_PARSER *p_cfg, FILE *p_file)
 {
-    memset(p_cfg, 0, sizeof(*p_cfg));
-    p_cfg->state = NEW_LINE;
-    p_cfg->p_file = p_file;
-    return RC_OK;
+	memset(p_cfg, 0, sizeof(*p_cfg));
+	p_cfg->state = NEW_LINE;
+	p_cfg->p_file = p_file;
+	return RC_OK;
 }
 
 /** Read one single option from file into the given buffer.
-	When the first separator is encountered it returns.
-	Actions:
-		- read chars while not eof
-		- skip comments (parts beginning with '#' and ending with '\n')
-		- switch to DATA STATE if non space char is encountered
-		- assume first name in lines to be a long option name by adding '--' if necesssary
-		- add data to buffer
-		- do not forget a 0 at the end
- * States:
- * NEW_LINE - wait here until some option. Add '--' if not already there
- * SPACE - between options. Like NEW_LINE but no additions
- * DATA - real data. Stop on space.
- * COMMENT - everything beginning with # until EOLine
- * ESCAPE - everything that is otherwise (incl. spaces). Next char is raw copied.
-*/
+    When the first separator is encountered it returns.
+    Actions:
+    - read chars while not eof
+    - skip comments (parts beginning with '#' and ending with '\n')
+    - switch to DATA STATE if non space char is encountered
+    - assume first name in lines to be a long option name by adding '--' if necesssary
+    - add data to buffer
+    - do not forget a 0 at the end
+    * States:
+    * NEW_LINE - wait here until some option. Add '--' if not already there
+    * SPACE - between options. Like NEW_LINE but no additions
+    * DATA - real data. Stop on space.
+    * COMMENT - everything beginning with # until EOLine
+    * ESCAPE - everything that is otherwise (incl. spaces). Next char is raw copied.
+    */
 static RC_TYPE parser_read_option(OPTION_FILE_PARSER *p_cfg, char *p_buffer, int maxlen)
 {
-    RC_TYPE rc = RC_OK;
-    BOOL parse_end = FALSE;
-    int count = 0;
-    *p_buffer = 0;
+	RC_TYPE rc = RC_OK;
+	BOOL parse_end = FALSE;
+	int count = 0;
+	*p_buffer = 0;
     
 	while(!parse_end)
 	{
 		char ch;
 		{
-            int n;
-            if ((n = fscanf(p_cfg->p_file, "%c", &ch)) < 0)
-    		{	
-                if (feof(p_cfg->p_file))
-                {
-                    break;
-                }
-    		    rc = RC_FILE_IO_READ_ERROR;		
-    			break;
-    		}
-        }
-
-        switch (p_cfg->state)
-        {
-        case NEW_LINE:
-                if (ch == '\\')
-                {
-                    p_cfg->state = ESCAPE;
-                    break;
-                }
-                if (ch == '#') /*comment*/
-                {
-                    p_cfg->state = COMMENT;
-                    break;
-                }
-                if (!isspace(ch))
-                {
-                    if (ch != '-')/*add '--' to first word in line*/
-                    {
-                        if ((rc = push_in_buffer("--", 2, p_buffer, &count, maxlen)) != RC_OK)
-                        {
-                            break;
-                        }
-                    }
-                    if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
-                    {
-                        break;
-                    }
-                    p_cfg->state = DATA;
-                    break;
-                }
-                /*skip actual leading  spaces*/
-            break;
-
-            case SPACE:
-                if (ch == '\\')
-                {
-                    p_cfg->state = ESCAPE;
-                    break;
-                }
-                if (ch == '#') /*comment*/
-                {
-                    p_cfg->state = COMMENT;
-                    break;
-                }
-                if (ch == '\n' || ch == '\r')
-                {
-                    p_cfg->state = NEW_LINE;
-                    break;
-                }
-                if (!isspace(ch))
-                {
-                    if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
-                    {
-                        break;
-                    }
-                    p_cfg->state = DATA;
-                    break;
-                }
-            break;
-
-            case COMMENT:
-                if (ch == '\n' || ch == '\r')
-                {
-                    p_cfg->state = NEW_LINE;
-                }
-                /*skip comments*/
-            break;
+			int n;
+			if ((n = fscanf(p_cfg->p_file, "%c", &ch)) < 0)
+			{	
+				if (feof(p_cfg->p_file))
+				{
+					break;
+				}
+				rc = RC_FILE_IO_READ_ERROR;		
+				break;
+			}
+		}
+
+		switch (p_cfg->state)
+		{
+		case NEW_LINE:
+			if (ch == '\\')
+			{
+				p_cfg->state = ESCAPE;
+				break;
+			}
+			if (ch == '#') /*comment*/
+			{
+				p_cfg->state = COMMENT;
+				break;
+			}
+			if (!isspace(ch))
+			{
+				if (ch != '-')/*add '--' to first word in line*/
+				{
+					if ((rc = push_in_buffer("--", 2, p_buffer, &count, maxlen)) != RC_OK)
+					{
+						break;
+					}
+				}
+				if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
+				{
+					break;
+				}
+				p_cfg->state = DATA;
+				break;
+			}
+			/*skip actual leading  spaces*/
+			break;
+
+		case SPACE:
+			if (ch == '\\')
+			{
+				p_cfg->state = ESCAPE;
+				break;
+			}
+			if (ch == '#') /*comment*/
+			{
+				p_cfg->state = COMMENT;
+				break;
+			}
+			if (ch == '\n' || ch == '\r')
+			{
+				p_cfg->state = NEW_LINE;
+				break;
+			}
+			if (!isspace(ch))
+			{
+				if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
+				{
+					break;
+				}
+				p_cfg->state = DATA;
+				break;
+			}
+			break;
+
+		case COMMENT:
+			if (ch == '\n' || ch == '\r')
+			{
+				p_cfg->state = NEW_LINE;
+			}
+			/*skip comments*/
+			break;
             
-            case DATA:
-                if (ch == '\\')
-                {
-                    p_cfg->state = ESCAPE;
-                    break;
-                }
-                if (ch == '#')
-                {
-                    p_cfg->state = COMMENT;
-                    break;
-                }
-                if (ch == '\n' || ch == '\r')
-                {
-                    p_cfg->state = NEW_LINE;
-                    parse_end = TRUE;
-                    break;
-                }
-                if (isspace(ch))
-                {
-                    p_cfg->state = SPACE;
-                    parse_end = TRUE;
-                    break;
-                }
-                /*actual data*/
-                if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
-                {
-                    break;
-                }
-            break;
-            case ESCAPE:
-                if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
-                {
-                    break;
-                }
-                p_cfg->state = DATA;
-            break;
-
-            default:
-                rc = RC_CMD_PARSER_INVALID_OPTION;                
-        }
-        if (rc != RC_OK)
-        {
-            break;
-        }
-    }
-    if (rc == RC_OK)
-    {
-        char ch = 0;
-        rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen);
-    }    
-    return rc;
+		case DATA:
+			if (ch == '\\')
+			{
+				p_cfg->state = ESCAPE;
+				break;
+			}
+			if (ch == '#')
+			{
+				p_cfg->state = COMMENT;
+				break;
+			}
+			if (ch == '\n' || ch == '\r')
+			{
+				p_cfg->state = NEW_LINE;
+				parse_end = TRUE;
+				break;
+			}
+			if (isspace(ch))
+			{
+				p_cfg->state = SPACE;
+				parse_end = TRUE;
+				break;
+			}
+			/*actual data*/
+			if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
+			{
+				break;
+			}
+			break;
+		case ESCAPE:
+			if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
+			{
+				break;
+			}
+			p_cfg->state = DATA;
+			break;
+
+		default:
+			rc = RC_CMD_PARSER_INVALID_OPTION;                
+		}
+		if (rc != RC_OK)
+		{
+			break;
+		}
+	}
+	if (rc == RC_OK)
+	{
+		char ch = 0;
+		rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen);
+	}    
+	return rc;
 }
 
 
 /**
-	This handler reads the data in the passed file name.
-	Then appends the words in the table (cutting all spaces) to the existing cmd line options.
-	It adds to the CMD_DATA struct.
-	Actions:
-		- open file
-		- read characters and cut spaces away
-		- add values one by one to the existing p_cmd data
+   This handler reads the data in the passed file name.
+   Then appends the words in the table (cutting all spaces) to the existing cmd line options.
+   It adds to the CMD_DATA struct.
+   Actions:
+   - open file
+   - read characters and cut spaces away
+   - add values one by one to the existing p_cmd data
 */
 static RC_TYPE get_options_from_file_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
@@ -824,13 +849,20 @@ static RC_TYPE get_options_from_file_han
 	FILE *p_file = NULL;
 	char *p_tmp_buffer = NULL;
 	const int buffer_size = DYNDNS_SERVER_NAME_LENGTH;
-    OPTION_FILE_PARSER parser;
+	OPTION_FILE_PARSER parser;
 	
 	if (!p_self || !p_cmd)
 	{
 		return RC_INVALID_POINTER;
 	}
 	
+	if (sizeof(p_self->info.credentials.my_password) < strlen(p_cmd->argv[current_nr]))
+	{
+		return  RC_DYNDNS_BUFFER_TOO_SMALL;
+	}
+
+	snprintf(p_self->cfgfile, sizeof(p_self->cfgfile), "%s", (p_cmd->argv[current_nr]));
+
 	do
 	{	
  		p_tmp_buffer = malloc(buffer_size);
@@ -847,23 +879,23 @@ static RC_TYPE get_options_from_file_han
 	  		break;
 	  	}
 
-        if ((rc = parser_init(&parser, p_file)) != RC_OK)
-        {
-            break;
-        }
+		if ((rc = parser_init(&parser, p_file)) != RC_OK)
+		{
+			break;
+		}
 
-    	while(!feof(p_file))
-     	{		 		
+		while(!feof(p_file))
+		{		 		
 	 		rc = parser_read_option(&parser,p_tmp_buffer, buffer_size);
 	 		if (rc != RC_OK)
 	 		{
 	 			break;
 	 		}
 
-            if (!strlen(p_tmp_buffer))
-            {
-                break;
-            }
+			if (!strlen(p_tmp_buffer))
+			{
+				break;
+			}
 
 	 		rc = cmd_add_val(p_cmd, p_tmp_buffer);
 	 		if (rc != RC_OK)
@@ -886,19 +918,19 @@ static RC_TYPE get_options_from_file_han
 }
 
 /* 
-	Set up all details:
-		- ip server name
-		- dns server name
-		- username, passwd
-		- ...
-	Implementation:
-		- load defaults
-		- parse cmd line
-        - assign settings that may change due to cmd line options
-		- check data
-	Note:
-		- if no argument is specified tries to call the cmd line parser
-	with the default cfg file path.
+   Set up all details:
+   - ip server name
+   - dns server name
+   - username, passwd
+   - ...
+   Implementation:
+   - load defaults
+   - parse cmd line
+   - assign settings that may change due to cmd line options
+   - check data
+   Note:
+   - if no argument is specified tries to call the cmd line parser
+   with the default cfg file path.
 */
 RC_TYPE get_config_data(DYN_DNS_CLIENT *p_self, int argc, char** argv)
 {
@@ -929,8 +961,11 @@ RC_TYPE get_config_data(DYN_DNS_CLIENT *
 			int custom_argc = sizeof(custom_argv) / sizeof(char*);
 			if (p_self->dbg.level > 0)
 			{
-            	DBG_PRINTF((LOG_NOTICE,"I:" MODULE_TAG "Using default config file %s\n", DYNDNS_DEFAULT_CONFIG_FILE));
+				DBG_PRINTF((LOG_NOTICE,"I:" MODULE_TAG "Using default config file %s\n", DYNDNS_DEFAULT_CONFIG_FILE));
 			}
+			
+			snprintf(p_self->cfgfile, sizeof(p_self->cfgfile), "%s", DYNDNS_DEFAULT_CONFIG_FILE);
+			
 			rc = get_cmd_parse_data(custom_argv, custom_argc, cmd_options_table);	
 		}
 		else
@@ -939,49 +974,49 @@ RC_TYPE get_config_data(DYN_DNS_CLIENT *
 		}
 
 		if (rc != RC_OK ||
-			p_self->abort)
+		    p_self->abort)
 		{
 			break;
 		}	
 
-        /*settings that may change due to cmd line options*/
-        {
-    		/*ip server*/
-            if (strlen(p_self->info.ip_server_name.name) == 0)
-            {
-                if (sizeof(p_self->info.ip_server_name.name) < strlen(p_self->info.p_dns_system->p_ip_server_name))
-                {
-                    rc = RC_DYNDNS_BUFFER_TOO_SMALL;
-                    break;
-                }
-                strcpy(p_self->info.ip_server_name.name, p_self->info.p_dns_system->p_ip_server_name);
-
-                if (sizeof(p_self->info.ip_server_url) < strlen(p_self->info.p_dns_system->p_ip_server_url))
-                {
-                    rc = RC_DYNDNS_BUFFER_TOO_SMALL;
-                    break;
-                }
-                strcpy(p_self->info.ip_server_url, p_self->info.p_dns_system->p_ip_server_url);				
-            }
+		/*settings that may change due to cmd line options*/
+		{
+			/*ip server*/
+			if (strlen(p_self->info.ip_server_name.name) == 0)
+			{
+				if (sizeof(p_self->info.ip_server_name.name) < strlen(p_self->info.p_dns_system->p_ip_server_name))
+				{
+					rc = RC_DYNDNS_BUFFER_TOO_SMALL;
+					break;
+				}
+				strcpy(p_self->info.ip_server_name.name, p_self->info.p_dns_system->p_ip_server_name);
+
+				if (sizeof(p_self->info.ip_server_url) < strlen(p_self->info.p_dns_system->p_ip_server_url))
+				{
+					rc = RC_DYNDNS_BUFFER_TOO_SMALL;
+					break;
+				}
+				strcpy(p_self->info.ip_server_url, p_self->info.p_dns_system->p_ip_server_url);				
+			}
             
-    		/*dyndns server*/
-            if (strlen(p_self->info.dyndns_server_name.name) == 0)
-            {
-        		if (sizeof(p_self->info.dyndns_server_name.name) < strlen(p_self->info.p_dns_system->p_dyndns_server_name))
-        		{
-        			rc = RC_DYNDNS_BUFFER_TOO_SMALL;
-        			break;
-        		}
-        		strcpy(p_self->info.dyndns_server_name.name, p_self->info.p_dns_system->p_dyndns_server_name);
-
-        		if (sizeof(p_self->info.dyndns_server_url) < strlen(p_self->info.p_dns_system->p_dyndns_server_url))
-        		{
-        			rc = RC_DYNDNS_BUFFER_TOO_SMALL;
-        			break;
-        		}
-        		strcpy(p_self->info.dyndns_server_url, p_self->info.p_dns_system->p_dyndns_server_url);
-            }
-        }
+			/*dyndns server*/
+			if (strlen(p_self->info.dyndns_server_name.name) == 0)
+			{
+				if (sizeof(p_self->info.dyndns_server_name.name) < strlen(p_self->info.p_dns_system->p_dyndns_server_name))
+				{
+					rc = RC_DYNDNS_BUFFER_TOO_SMALL;
+					break;
+				}
+				strcpy(p_self->info.dyndns_server_name.name, p_self->info.p_dns_system->p_dyndns_server_name);
+
+				if (sizeof(p_self->info.dyndns_server_url) < strlen(p_self->info.p_dns_system->p_dyndns_server_url))
+				{
+					rc = RC_DYNDNS_BUFFER_TOO_SMALL;
+					break;
+				}
+				strcpy(p_self->info.dyndns_server_url, p_self->info.p_dns_system->p_dyndns_server_url);
+			}
+		}
 
 		/*check if the neccessary params have been provided*/
 		if ( 
diff -pruN inadyn-v1.96.2.old/src/os.c inadyn-v1.96.2/src/os.c
--- inadyn-v1.96.2.old/src/os.c	2008-10-23 14:10:37.000000000 +0200
+++ inadyn-v1.96.2/src/os.c	2008-10-23 16:46:12.000000000 +0200
@@ -97,16 +97,7 @@ void os_printf(int prio, char *fmt, ... 
     vsnprintf(message, sizeof(message), fmt, args);
     va_end(args);
 
-	#ifdef HAVE_OS_SYSLOG
-    if (get_dbg_dest() == DBG_SYS_LOG)
-    {
-        syslog(prio, "%s",message);
-    }
-    else
-	#endif
-    {
         printf("%s",message); fflush(stdout);
-    }
 
     return;
 
